<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: relational_tags.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: relational_tags.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Relational tagging library.
 * 
 * @author Owen Gallagher
 */

/**
 * Handle optional imports.
 * 
 * @private
 * 
 * @param {Array} opt_libs The resolved optional libraries in the following order: 
 * temp_js_logger
 */ 
function on_opt_libs(opt_libs) {
	return new Promise(function(resolve) {
		const logging = opt_libs[0]
		
		logging.config({
			level: 'debug',
			with_timestamp: false, 
			caller_name: 'relational_tags', 
			with_lineno: false, 
			parse_level_prefix: true, 
			with_level: true,
			with_always_level_name: true, 
			with_cli_colors: true
		})
		console.log('debug configured logging')
		
		logging.imports_promise.then(resolve)
	})
}

// optional dependencies
Promise.all([
	import('temp_js_logger')
]).then(
	on_opt_libs,
	function(err) {
		console.log('warning failed to import optional dependencies')
	}
)
.then(function() {
	console.log('debug begin define relational_tags library')
	
	/**
	 * RelationalTag class.
	 * 
	 * A relational tag instance can be connected to an entity to categorize it, and also be connected to other 
	 * relational tags.
	 * 
	 * All module-level members and methods are first available as static members of this class for convenience.
	 */
	class RelationalTag {
		/**
		 * Constructor to create a new relational tag.
		 * 
		 * @param {String} name The name/label/value of this tag.
		 */
		constructor(name) {
			/**
			 * Relational tag name.
			 * 
			 * @type String
			 */
			this.name = RelationalTag._is_case_sensitive ? name : name.toLowerCase()
			
			if (name in RelationalTag.all_tags) {
				throw new RelationalTagException(
					`tag ${this.name} already exists`, RelationalTagException.TYPE_GENERIC
				)
			}
			else {
				// register tag
				RelationalTag.all_tags[this.name] = this
				
				/**
				 * Relational tag connections. This is how we keep track of tag--[entity,tag] relationships.
				 * 
				 * @type Object
				 */ 
				this.connections = {}
				
				console.log(`info created new tag ${this.name}`)
			}
		}
		
		/**
		 * Convenience wrapper for {@link #connect}.
		 * 
		 * @return {RelationalTagConnection}
		 */ 
		connect_to(other, connection_type) {
			return RelationalTag.connect(this, other, connection_type)
		}
	}
	
	// RelationalTag static variables
	
	/**
	 * Whether tag names are case sensitive.
	 * @memberOf RelationalTag
	 * @type Boolean
	 */ 
	RelationalTag._is_case_sensitive = false
	
	/**
	 * All relational tags.
	 * @memberOf RelationalTag
	 * 
	 * Structure = { name : tag }.
	 * 
	 * @type Object
	 */ 
	RelationalTag.all_tags = {}
	
	/**
	 * All tagged entities.
	 * @memberOf RelationalTag
	 * 
	 * Structure = { entity : { tag : connection } }.
	 * 
	 * @type Object
	 */ 
	RelationalTag.tagged_entities = {}
	
	// RelationalTag static methods
	
	/**
	 * Initial configuration.
	 * @memberOf RelationalTag
	 * 
	 * @param {Boolean} is_case_sensitive
	 */
	RelationalTag.config = function(is_case_sensitive) {
		RelationalTag._is_case_sensitive = is_case_sensitive
	}
	
	/**
	 * Create a connection between a source and target with the given connection type.
	 * @memberOf RelationalTag
	 * 
	 * @param {RelationalTag|RelationalTagConnection} tag_or_connection
	 * 
	 * @param {Object} target
	 * 
	 * @param {String} connection_type
	 */
	RelationalTag.connect = function(tag_or_connection, target, connection_type) {
		source_is_connection = (tag_or_connection instanceof RelationalTagConnection)
		target_is_tag = (target instanceof RelationalTag)
		
		// resolve type as default
		if (connection_type === undefined &amp;&amp; !source_is_connection) {
			if (target_is_tag) {
				connection_type = RelationalTagConnection.TYPE_TO_TAG_UNDIRECTED
			}
			else {
				connection_type = RelationalTagconnection.TYPE_TO_ENT
			}
		}
		
		if (source_is_connection) {
			console.log(`debug rtag.connect called w connection; converting to source`)
			let conn = tag_or_connection
			RelationalTag.connect(conn.source, conn.target, conn.type)
		}
		else {
			let tag = tag_or_connection
			
			// connection
			let conn = new RelationalTagConnection(tag, target, connection_type)
			tag.connections[target] = conn
			
			// inverse connection
			if (target_is_tag) {
				target.connections[tag] = connection.inverse()
			}
			else {
				if (!(target in RelationalTag.tagged_entities)) {
					console.log(`info new tagged entity ${target}`)
					RelationalTag.tagged_entities[target] = {}
				}
				
				RelationalTag.tagged_entities[target][tag] = connection.inverse()
			}
		}
	}
	
	/**
	 * Class for all exceptions/errors specific to relational tags.
	 */ 
	class RelationalTagException {
		/**
		 * Create a relational tag exception instance.
		 * 
		 * @param {String} message Error message.
		 * 
		 * @param {String} type Error type.
		 */
		constructor(message, type) {
			this.name = 'RelationalTagException'
			this.message = message
			this.type = type === undefined ? RelationalTagException.TYPE_GENERIC : type
		}
		
		/**
		 * Format exception as readable string.
		 * 
		 * @return {String}
		 */
		toString() {
			return `${this.name}.${this.type}: ${this.message}`
		}
	}
	
	// RelationalTagException static variables
	
	/**
	 * Relational tag exception types, which are converted into static constants.
	 * @memberOf RelationalTagException
	 * 
	 * Ex. 'GENERIC' &amp;rarr; RelationalTagException.TYPE_GENERIC = 'GENERIC'.
	 * 
	 * @type Array
	 */
	RelationalTagException.TYPES = [
		'GENERIC',
		'MISSING',
		'WRONG_TYPE'
	]
	for (let type of RelationalTagException.TYPES) {
		RelationalTagException[`TYPE_${type.toUpperCase()}`] = type.toUpperCase()
	}
	console.log(`debug RelationalTagException.TYPES = ${JSON.stringify(RelationalTagException.TYPES)}`)
	
	/**
	 * Connection between a relational tag and another tag or entity.
	 */ 
	class RelationalTagConnection {
		/**
		 * Create a new connection instance. This should not be called directly, as it doesn't register
		 * itself with the source or target. Use {@link RelationalTag#connect} instead.
		 * 
		 * @param {RelationalTag} source
		 * 
		 * @param {RelationalTag|Object} target
		 * 
		 * @param {String} type
		 * 
		 * @throws RelationalTagException The connection type is incompatible with the given source
		 * and target.
		 */
		constructor(source, target, type) {
			this.source = source
			this.target = target
			this.type = type
			
			if (
				RelationalTagConnection._TAG_TAG_TYPES.indexOf(type) != -1 &amp;&amp; 
				!(target instanceof RelationalTag)
			) {
				throw new RelationalTagException('', RelationalTagException.TYPE_TYPE_WRONG_TYPE)
			}
		}
		
		/**
		 * Return a new connection that is the inverse of this one, by swapping source and target and
		 * using the inverse connection type.
		 * 
		 * @returns RelationalTagConnection
		 */
		inverse() {
			return new RelationalTagConnection(
				this.target,
				this.source,
				RelationalTagConnection.inverse_type(this.type)
			)
		}
		
		/**
		 * Format properties of the connection into a readable one line string.
		 * 
		 * @returns String
		 */ 
		toString() {
			return `${this.source}=${this.type}=${this.target}`
		}
	}
	
	// RelationalTagConnection static variables
	
	/**
	 * Relational tag connection types, which are converted into static constants.
	 * @memberOf RelationalTagConnection
	 * 
	 * Ex. 'TO_TAG_UNDIRECTED' &amp;rarr; RelationalTagConnection.TYPE_TO_TAG_UNDIRECTED = 'TO_TAG_UNDIRECTED'.
	 * 
	 * @type Array
	 */
	RelationalTagConnection.TYPES = [
	    'TO_TAG_UNDIRECTED',
	    'TO_TAG_PARENT',
		'TO_TAG_CHILD',
		'TO_ENT',
	    'ENT_TO_TAG'
	]
	
	/**
	 * Connection types between tags.
	 * @memberOf RelationalTagConnection
	 */
	RelationalTagConnection._TAG_TAG_TYPES = []
	/**
	 * Connection types between a tag and an entity.
	 * @memberOf RelationalTagConnection
	 */
	RelationalTagconnection._TAG_ENT_TYPES = []
	
	for (let type of RelationalTagConnection.TYPES) {
		let T = type.toUpperCase()
		
		RelationalTagConnection[`TYPE_${T}`] = T
		
		if (T.indexOf('TAG') != -1) {
			RelationalTagConnection._TAG_TAG_TYPES.push(T)
		}
		
		if (T.indexOf('ENT') != -1) {
			RelationalTagConnection._TAG_ENT_TYPES.push(T)
		}
	}
	console.log(`debug RelationalTagException.TYPES = ${JSON.stringify(RelationalTagException.TYPES)}`)
	
	// RelationalTagConnection static methods
	
	/**
	 * Return the inverse of the given connection type.
	 * @memberOf RelationalTagConnection
	 * 
	 * @param {String} type
	 * 
	 * @return String
	 */ 
	RelationalTagConnection.inverse_type = function(type) {
		switch (type) {
			case RelationalTagConnection.TYPE_TO_TAG_PARENT:
				return RelationalTagConnection.TYPE_TO_TAG_CHILD
				
			case RelationalTagConnection.TYPE_TO_TAG_CHILD:
				return RelationalTagConnection.TYPE_TO_TAG_PARENT
				
			case RelationalTagConnection.TYPE_TO_ENT:
				return RelationalTagConnection.TYPE_ENT_TO_TAG
				
			case RelationalTagConnection.TYPE_ENT_TO_TAG:
				return RelationalTagConnection.TYPE_TO_ENT
				
			default:
				return type
		}
	}
	
	// exports
	
	exports.RelationalTag = RelationalTag
	exports.RelationalTagException = RelationalTagException
	
	console.log('debug end define relational_tags library')
})
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="RelationalTag.html">RelationalTag</a></li><li><a href="RelationalTagConnection.html">RelationalTagConnection</a></li><li><a href="RelationalTagException.html">RelationalTagException</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri Mar 11 2022 00:22:57 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
