<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>relational_tags API documentation</title>
<meta name="description" content="Relational tagging package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>relational_tags</code></h1>
</header>
<section id="section-intro">
<p>Relational tagging package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Owen Gallagher
# 13 June 2021

&#34;&#34;&#34;Relational tagging package.
&#34;&#34;&#34;

# imports

from typing import List, Dict, Union, Any, Tuple
import logging
from logging import Logger

# module vars

VERSION:str = &#39;0.0.4&#39;
&#34;&#34;&#34;Package version.
&#34;&#34;&#34;

# types

class HashableEntity:
    &#34;&#34;&#34;If an entity is not hashable, it is wrapped with this class.
    
    You should not need to use this class yourself.
    &#34;&#34;&#34;
    
    def __init__(self, entity:Any):
        try:
            self.hash = hash(&#39;{}@{}&#39;.format(type(entity),id(entity)))
            &#34;&#34;&#34;Hash value, using the type and memory address of the entity.
            &#34;&#34;&#34;
        
            self.entity = entity
            &#34;&#34;&#34;Entity value.&#34;&#34;&#34;
            
        except:
            raise RelationalTagError(
                &#39;unable to create relational entity from {}&#39;.format(entity),
                RelationalTagError.TYPE_HASH_FAIL
            )
    # end __init__
    
    def __eq__(self, other:Any) -&gt; bool:
        if isinstance(other,HashableEntity):
            return self.hash == other.hash
        
        if &#39;__hash__&#39; not in dir(other) or entity.__hash__ is None:
            return self.hash == HashableEntity(other).hash
        
        else:
            return False
    # end __eq__
    
    def __hash__(self):
        return self.hash
    # end __hash__
# end HashableEntity

class RelationalTag:
    &#34;&#34;&#34;Relational tag class.
    
    A relational tag can be connected to an entity to categorize it, and also be connected to other
    relational tags.
    &#34;&#34;&#34;
    
    log:Logger = logging.getLogger(&#39;{}.RelationalTag&#39;.format(__name__))
    
    _is_case_sensitive:bool = False
    &#34;&#34;&#34;Whether tag uniqueness is case-sensitive.
    
    **default** `False`
    &#34;&#34;&#34;
    
    all_tags:Dict[str, &#39;RelationalTag&#39;] = {}
    &#34;&#34;&#34;All relational tags.&#34;&#34;&#34;
    
    _tagged_entities:Dict[Any, Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]] = {}
    &#34;&#34;&#34;All entities that have been assigned tags.
    
    Connections dict key per entity is equal to the connection&#39;s `target`.
    &#34;&#34;&#34;
    
    @classmethod
    def config(cls, is_case_sensitive:bool=False):
        &#34;&#34;&#34;RelationalTag static config.
        &#34;&#34;&#34;
        
        cls._is_case_sensitive = is_case_sensitive
    # end config
    
    @classmethod
    def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = RelationalTag(name=name)
            return rtag
        
        except RelationalTagError as e:
            cls.log.warning(str(e))
            
            if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
                return cls.all_tags[name]
            else:
                raise e
        # end except
    # end new
    
    @classmethod
    def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = cls.all_tags[name]
            return rtag
            
        except KeyError as e:
            cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
            
            if new_if_missing:
                rtag = RelationalTag(name=name)
                return rtag
            else:
                raise RelationalTagError(
                    &#39;tag {} missing&#39;.format(name), 
                    RelationalTagError.TYPE_MISSING
                )
        # end except
    # end get
    
    @classmethod
    def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
        try:
            # convert tag to RelationalTag
            if isinstance(tag,str):
                if not cls._is_case_sensitive:
                    tag = tag.lower()
                
                tag = cls.all_tags[tag]
            # end if not RelationalTag
            
            cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
            
            # delete references from others
            for connection in tag.connections.values():
                other = connection.source
                
                if isinstance(other, RelationalTag):
                    # disconnect from other tag
                    del other.connections[tag]
                
                else:
                    # disconnect from entity
                    del _tagged_entities[other][tag]
            # end for connection in connections
            
            # delete tag
            del cls.all_tags[tag.name]
        
        except KeyError as e:
            cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))
    # end delete
    
    @classmethod
    def clear(cls) -&gt; int:
        num_tags = len(cls.all_tags)
        
        cls.all_tags = {}
        cls._tagged_entities = {}
        
        return num_tags
    # end clear
    
    @classmethod
    def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
        &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
        
        There are multiple ways to define a relational tags system:
        
        ## From Save
        
        Pass a list of `RelationalTag` instances as the `tags` arg.
        
        ## Flat
        
        Pass a list of tag name strings. Tags will not have any relationships with each other.
        Repeated tag names are allowed.
        
        Example:
        
        ```
        [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
        ```
        
        ## Hierarchy
        
        Pass a dict, where each key is a tag name string, and each value is either a single
        tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
        
        Example:
        
        ```
        {
            &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
            &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
            &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
            &#39;sport&#39;: &#39;football&#39;
        }
        ```
        
        ## Args
        
        **tags** Relational tags, either as a list or dict. Entities not supported.
        
        **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
        of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
        `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if isinstance(tags, List):
            for tag in tags:
                if isinstance(tag,RelationalTag):
                    if tag in all_tags:
                        log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                    
                    all_tags[tag.name] = tag
                
                elif isinstance(tag,str):
                    cls.new(tag, get_if_exists=True)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported tag type {}&#39;.format(type(tag)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag in tags
            
        elif isinstance(tags, Dict):
            for tag, value in tags.items():
                # create new parent tag
                rtag = cls.new(tag, get_if_exists=True)
                
                if isinstance(value,List):
                    # tag to many
                    for val in value:
                        ttag = cls.get(val, new_if_missing=True)
                        cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
                
                elif isinstance(value,str):
                    # tag to one
                    ttag = cls.get(value, new_if_missing=True)
                    cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported target type {}&#39;.format(type(value)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag,value in tags
            
        else:
            raise RelationalTagError(
                &#39;unsupported tags type {}&#39;.format(type(tags)),
                type=RelationalTagError.TYPE_WRONG_TYPE
            )
        
        return cls.all_tags.values()
    # end load
    
    @classmethod
    def _entity_to_hashable(cls,entity:Any) -&gt; Union[HashableEntity,Any]:
        &#34;&#34;&#34;Wraps the entity in a `HashableEntity` instance if not hashable already.
        &#34;&#34;&#34;
        
        if &#39;__hash__&#39; in dir(entity) and entity.__hash__ is not None:
            return entity
        
        else:
            return HashableEntity(entity)
    # end _entity_to_hashable
    
    @classmethod
    def _hashable_to_entity(cls,entity:Union[HashableEntity,Any]) -&gt; Any:
        if isinstance(entity,HashableEntity):
            return entity.entity
        
        else:
            return entity
    # end _hashable_to_entity
    
    @classmethod
    def connect(cls, tag:&#39;RelationalTag&#39;, target:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Connect a tag with a target.
        &#34;&#34;&#34;
        
        # resolve connection type
        if connection_type is None:
            if isinstance(target,RelationalTag):
                connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
            else:
                connection_type = RelationalTagConnection.TO_ENT
        
        # connection
        connection = RelationalTagConnection(
            source=tag,
            target=target,
            connection_type=connection_type
        )
        tag.connections[cls._entity_to_hashable(target)] = connection
        
        # inverse connection
        inverse_connection = connection.inverse()
        if isinstance(target,RelationalTag):
            # tag connection
            target.connections[tag] = inverse_connection
        else:
            # entity connection
            entity = cls._entity_to_hashable(target)
            
            if not entity in cls._tagged_entities:
                cls._tagged_entities[entity] = {}
            
            cls._tagged_entities[entity][tag] = inverse_connection
        
        # return
        return connection
    # end connect
    
    @classmethod
    def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
        &#34;&#34;&#34;Disconnect a tag from a target.
        
        ## Args
        
        **tag_or_connection** Either a relational tag source, or the connection that contains info
        about both the source and the target.
        
        **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
        &#34;&#34;&#34;
        
        if isinstance(tag_or_connection, RelationalTagConnection):
            # disconnect connection
            cls.disconnect(tag_or_connection.source, tag_or_connection.target)
        
        else:
            hashable_target = cls._entity_to_hashable(target)
            
            # disconnect tag-target
            del tag.connections[hashable_target]
            
            # TODO here, then finish RelationalTag.load
            if isinstance(target,RelationalTag):
                # tag connection
                # disconnect target-tag
                del target.connections[tag]
            
            else:
                # entity connection
                # disconnect target-tag
                if hashable_target in _tagged_entities:
                    del _tagged_entities[hashable_target][tag]
                    
                else:
                    log.warning(&#39;entity {} already untagged&#39;.format(target))
    # end connect
    
    @classmethod
    def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
        tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
        
        for relational_entity,connections in cls._tagged_entities.items():
            raw_entity = cls._hashable_to_entity(relational_entity)
            tagged_entities.append((raw_entity, connections))
        
        return tagged_entities
    # end get_tagged_entities
    
    def __init__(self, name:str):
        &#34;&#34;&#34;RelationalTag constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if not cls._is_case_sensitive:
            name = name.lower()
        
        if name in cls.all_tags:
            raise RelationalTagError(&#39;tag {} already exists&#39;.format(name))
        
        else:
            self.name = name
            &#34;&#34;&#34;Tag name.
            &#34;&#34;&#34;
            
            self.connections:Dict[Union[RelationalTag,Any], RelationalTagConnection] = {}
            &#34;&#34;&#34;Tag connections (relationships).
            
            Connection keys are equal to `RelationalTagConnection.target`.
            &#34;&#34;&#34;
            
            cls.all_tags[self.name] = self
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTag string representation.
        &#34;&#34;&#34;
        
        return &#39;{}[{}]&#39;.format(
            self.name,
            &#39; &#39;.join([str(conn) for conn in self.connections.values()])
        )
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTag) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash(self.name)
    # end __hash__
    
    def connect_to(self, other:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None):
        &#34;&#34;&#34;Connect tag to another tag or entity.
        
        Calls the class method `RelationalTag.connect`.
        &#34;&#34;&#34;
        
        type(self).connect(tag=self,target=other,connection_type=connection_type)
    # end connect_to
    
    def disconnect_to(self, other:Union[&#39;RelationalTag&#39;,Any]):
        &#34;&#34;&#34;Disconnect tag from another tag or entity.
        
        Calls the class method `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        type(self).disconnect(tag=self,target=other)
    # end disconnect_to
    
    def delete_self(self):
        type(self).delete(self)
    # end delete
# end RelationalTag

class RelationalTagConnection:
    &#34;&#34;&#34;Relational tag connection.
    &#34;&#34;&#34;
    
    log:logging.Logger = logging.getLogger(&#39;{}.RelationalTagConnection&#39;.format(__name__))
    
    TO_TAG_UNDIRECTED:int = 1
    &#34;&#34;&#34;Undirected tag-tag connection.&#34;&#34;&#34;
    TO_TAG_PARENT:int = 2
    &#34;&#34;&#34;Child-parent tag-tag connection.&#34;&#34;&#34;
    TO_TAG_CHILD:int = 3
    &#34;&#34;&#34;Parent-child tag-tag connection.&#34;&#34;&#34;
    TO_ENT:int = 4
    &#34;&#34;&#34;Tag-entity connection.&#34;&#34;&#34;
    ENT_TO_TAG:int = 5
    &#34;&#34;&#34;Entity-tag connection.&#34;&#34;&#34;
    
    _TAG_TAG_TYPES:List[int] = [TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD]
    &#34;&#34;&#34;All tag-tag connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    &#34;&#34;&#34;
    
    _TAG_ENT_TYPES:List[int] = [TO_ENT,ENT_TO_TAG]
    &#34;&#34;&#34;All tag-entity connection types.
    
    ## Items
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    _TYPES:List[int] = [
        TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD,TO_ENT,ENT_TO_TAG
    ]
    &#34;&#34;&#34;All connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    @classmethod
    def type_to_str(cls,type:int) -&gt; str:
        if type == cls.TO_TAG_UNDIRECTED:
            return &#39;to-tag-undirected&#39;
        
        elif type == cls.TO_TAG_PARENT:
            return &#39;to-tag-parent&#39;
        
        elif type == cls.TO_TAG_CHILD:
            return &#39;to-tag-child&#39;
            
        elif type == cls.TO_ENT:
            return &#39;to-entity&#39;
            
        elif type == cls.ENT_TO_TAG:
            return &#39;entity-to-tag&#39;
    # end type_to_str
    
    @classmethod
    def inverse_type(cls,type:int) -&gt; int:
        if type == cls.TO_TAG_PARENT:
            return cls.TO_TAG_CHILD
        
        elif type == cls.TO_TAG_CHILD:
            return cls.TO_TAG_PARENT
        
        elif type == cls.TO_ENT:
            return cls.ENT_TO_TAG
            
        elif type == cls.ENT_TO_TAG:
            return cls.TO_ENT
            
        else:
            return type
    # end reverse_type
    
    def __init__(self, source:RelationalTag, target:Union[RelationalTag,Any], connection_type=TO_ENT):
        &#34;&#34;&#34;RelationalTagConnection constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        self.source:RelationalTag = source
        &#34;&#34;&#34;Connection source; must be a `RelationalTag`.
        &#34;&#34;&#34;
        
        self.target:Union[RelationalTag,Any] = target
        &#34;&#34;&#34;Connection target; either a `RelationalTag`, or an entity.
        &#34;&#34;&#34;
        
        self.type = connection_type
        &#34;&#34;&#34;Connection type. See `_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if self.type in cls._TAG_TAG_TYPES and not isinstance(target,RelationalTag):
            raise RelationalTagError(
                &#39;cannot create {} connection with non-tag {}&#39;.format(
                    cls.type_to_str(self.type),
                    target
                ),
                RelationalTagError.TYPE_WRONG_TYPE
            )
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTagConnection string representation.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if isinstance(self.source,RelationalTag):
            source_str = self.source.name
        else:
            source_str = self.source
        
        if isinstance(self.target,RelationalTag):
            target_str = self.target.name
        else:
            target_str = self.target
        
        return &#39;{}={}={}&#39;.format(source_str,cls.type_to_str(self.type),target_str)
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTagConnection) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash((self.source, self.target, self.type))
    # end __hash__
    
    def inverse(self) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Return inverse connection.
        &#34;&#34;&#34;
        
        return RelationalTagConnection(
            source=self.target,
            target=self.source,
            connection_type=type(self).inverse_type(self.type)
        )
    # end inverse
    
    def disconnect(self):
        &#34;&#34;&#34;Disconnect source and target.
        
        Convenience method for `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        RelationalTag.disconnect(tag_or_connection=self)
    # end disconnect
# end RelationalTagConnection

class RelationalTagError(Exception):
    &#34;&#34;&#34;Relational tag error.
    &#34;&#34;&#34;
    
    TYPE_COLLISION = 1
    TYPE_MISSING = 2
    TYPE_WRONG_TYPE = 3
    TYPE_HASH_FAIL = 4
    
    def __init__(self, message, type=TYPE_COLLISION):
        &#34;&#34;&#34;RelationalTagError constructor.
        &#34;&#34;&#34;
        
        super().__init__(message)
        
        self.type = type
    # end __init__
# end RelationalTagError

# alias vars

all_tags = RelationalTag.all_tags
&#34;&#34;&#34;Alias for `RelationalTag.all_tags`.
&#34;&#34;&#34;

# alias methods

config = RelationalTag.config
&#34;&#34;&#34;Alias for `RelationalTag.config`&#34;&#34;&#34;

new = RelationalTag.new
&#34;&#34;&#34;Alias for `RelationalTag.new`&#34;&#34;&#34;

get = RelationalTag.get
&#34;&#34;&#34;Alias for `RelationalTag.get`&#34;&#34;&#34;

delete = RelationalTag.delete
&#34;&#34;&#34;Alias for `RelationalTag.delete`&#34;&#34;&#34;

clear = RelationalTag.clear
&#34;&#34;&#34;Alias for `RelationalTag.clear`&#34;&#34;&#34;

load = RelationalTag.load
&#34;&#34;&#34;Alias for `RelationalTag.load`&#34;&#34;&#34;

connect = RelationalTag.connect
&#34;&#34;&#34;Alias for `RelationalTag.connect`&#34;&#34;&#34;

disconnect = RelationalTag.disconnect
&#34;&#34;&#34;Alias for `RelationalTag.disconnect`&#34;&#34;&#34;

# exports

__all__ = [
    &#39;VERSION&#39;,
    &#39;RelationalTag&#39;,
    &#39;RelationalTagConnection&#39;,
    &#39;RelationalTagError&#39;,
    &#39;all_tags&#39;,
    &#39;config&#39;,
    &#39;new&#39;,
    &#39;get&#39;,
    &#39;delete&#39;,
    &#39;clear&#39;,
    &#39;load&#39;,
    &#39;connect&#39;,
    &#39;disconnect&#39;
]</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="relational_tags.VERSION"><code class="name">var <span class="ident">VERSION</span> : str</code></dt>
<dd>
<div class="desc"><p>Package version.</p></div>
</dd>
<dt id="relational_tags.all_tags"><code class="name">var <span class="ident">all_tags</span></code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="relational_tags.RelationalTag.all_tags" href="#relational_tags.RelationalTag.all_tags">RelationalTag.all_tags</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="relational_tags.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clear(cls) -&gt; int:
    num_tags = len(cls.all_tags)
    
    cls.all_tags = {}
    cls._tagged_entities = {}
    
    return num_tags</code></pre>
</details>
</dd>
<dt id="relational_tags.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>is_case_sensitive: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>RelationalTag static config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def config(cls, is_case_sensitive:bool=False):
    &#34;&#34;&#34;RelationalTag static config.
    &#34;&#34;&#34;
    
    cls._is_case_sensitive = is_case_sensitive</code></pre>
</details>
</dd>
<dt id="relational_tags.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>tag: <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any], connection_type: int = None) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a tag with a target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def connect(cls, tag:&#39;RelationalTag&#39;, target:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Connect a tag with a target.
    &#34;&#34;&#34;
    
    # resolve connection type
    if connection_type is None:
        if isinstance(target,RelationalTag):
            connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
        else:
            connection_type = RelationalTagConnection.TO_ENT
    
    # connection
    connection = RelationalTagConnection(
        source=tag,
        target=target,
        connection_type=connection_type
    )
    tag.connections[cls._entity_to_hashable(target)] = connection
    
    # inverse connection
    inverse_connection = connection.inverse()
    if isinstance(target,RelationalTag):
        # tag connection
        target.connections[tag] = inverse_connection
    else:
        # entity connection
        entity = cls._entity_to_hashable(target)
        
        if not entity in cls._tagged_entities:
            cls._tagged_entities[entity] = {}
        
        cls._tagged_entities[entity][tag] = inverse_connection
    
    # return
    return connection</code></pre>
</details>
</dd>
<dt id="relational_tags.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>tag: Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
    try:
        # convert tag to RelationalTag
        if isinstance(tag,str):
            if not cls._is_case_sensitive:
                tag = tag.lower()
            
            tag = cls.all_tags[tag]
        # end if not RelationalTag
        
        cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
        
        # delete references from others
        for connection in tag.connections.values():
            other = connection.source
            
            if isinstance(other, RelationalTag):
                # disconnect from other tag
                del other.connections[tag]
            
            else:
                # disconnect from entity
                del _tagged_entities[other][tag]
        # end for connection in connections
        
        # delete tag
        del cls.all_tags[tag.name]
    
    except KeyError as e:
        cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))</code></pre>
</details>
</dd>
<dt id="relational_tags.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>tag_or_connection: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), ForwardRef('<a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>')], target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect a tag from a target.</p>
<h2 id="args">Args</h2>
<p><strong>tag_or_connection</strong> Either a relational tag source, or the connection that contains info
about both the source and the target.</p>
<p><strong>target</strong> Connection target, or <code>None</code> if a connection was provided for <code>tag_or_connection</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
    &#34;&#34;&#34;Disconnect a tag from a target.
    
    ## Args
    
    **tag_or_connection** Either a relational tag source, or the connection that contains info
    about both the source and the target.
    
    **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
    &#34;&#34;&#34;
    
    if isinstance(tag_or_connection, RelationalTagConnection):
        # disconnect connection
        cls.disconnect(tag_or_connection.source, tag_or_connection.target)
    
    else:
        hashable_target = cls._entity_to_hashable(target)
        
        # disconnect tag-target
        del tag.connections[hashable_target]
        
        # TODO here, then finish RelationalTag.load
        if isinstance(target,RelationalTag):
            # tag connection
            # disconnect target-tag
            del target.connections[tag]
        
        else:
            # entity connection
            # disconnect target-tag
            if hashable_target in _tagged_entities:
                del _tagged_entities[hashable_target][tag]
                
            else:
                log.warning(&#39;entity {} already untagged&#39;.format(target))</code></pre>
</details>
</dd>
<dt id="relational_tags.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name: str, new_if_missing: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = cls.all_tags[name]
        return rtag
        
    except KeyError as e:
        cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
        
        if new_if_missing:
            rtag = RelationalTag(name=name)
            return rtag
        else:
            raise RelationalTagError(
                &#39;tag {} missing&#39;.format(name), 
                RelationalTagError.TYPE_MISSING
            )
    # end except</code></pre>
</details>
</dd>
<dt id="relational_tags.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>tags: Union[List[Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')]], Dict[str, Union[str, List[str]]]], tag_tag_type: int = 'RelationalTagConnection.TO_TAG_CHILD') ‑> List[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a set of tags, including optional connection info for each.</p>
<p>There are multiple ways to define a relational tags system:</p>
<h2 id="from-save">From Save</h2>
<p>Pass a list of <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code> instances as the <code>tags</code> arg.</p>
<h2 id="flat">Flat</h2>
<p>Pass a list of tag name strings. Tags will not have any relationships with each other.
Repeated tag names are allowed.</p>
<p>Example:</p>
<pre><code>['apple','banana','cinnamon','donut']
</code></pre>
<h2 id="hierarchy">Hierarchy</h2>
<p>Pass a dict, where each key is a tag name string, and each value is either a single
tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.</p>
<p>Example:</p>
<pre><code>{
    'fruit': ['apple','banana','orange'],
    'food': ['fruit','vegetable'],
    'color': ['red','blue','green','orange'],
    'sport': 'football'
}
</code></pre>
<h2 id="args">Args</h2>
<p><strong>tags</strong> Relational tags, either as a list or dict. Entities not supported.</p>
<p><strong>tag_tag_type</strong> Specify what a key-value relationship in a dictionary means. Default
of <code><a title="relational_tags.RelationalTagConnection.TO_TAG_CHILD" href="#relational_tags.RelationalTagConnection.TO_TAG_CHILD">RelationalTagConnection.TO_TAG_CHILD</a></code> means the key is the parent of the value. See
<code>RelationalTagConnection._TAG_TAG_TYPES</code> for possible values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
    &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
    
    There are multiple ways to define a relational tags system:
    
    ## From Save
    
    Pass a list of `RelationalTag` instances as the `tags` arg.
    
    ## Flat
    
    Pass a list of tag name strings. Tags will not have any relationships with each other.
    Repeated tag names are allowed.
    
    Example:
    
    ```
    [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
    ```
    
    ## Hierarchy
    
    Pass a dict, where each key is a tag name string, and each value is either a single
    tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
    
    Example:
    
    ```
    {
        &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
        &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
        &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
        &#39;sport&#39;: &#39;football&#39;
    }
    ```
    
    ## Args
    
    **tags** Relational tags, either as a list or dict. Entities not supported.
    
    **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
    of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
    `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
    &#34;&#34;&#34;
    
    if isinstance(tags, List):
        for tag in tags:
            if isinstance(tag,RelationalTag):
                if tag in all_tags:
                    log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                
                all_tags[tag.name] = tag
            
            elif isinstance(tag,str):
                cls.new(tag, get_if_exists=True)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported tag type {}&#39;.format(type(tag)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag in tags
        
    elif isinstance(tags, Dict):
        for tag, value in tags.items():
            # create new parent tag
            rtag = cls.new(tag, get_if_exists=True)
            
            if isinstance(value,List):
                # tag to many
                for val in value:
                    ttag = cls.get(val, new_if_missing=True)
                    cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
            
            elif isinstance(value,str):
                # tag to one
                ttag = cls.get(value, new_if_missing=True)
                cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported target type {}&#39;.format(type(value)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag,value in tags
        
    else:
        raise RelationalTagError(
            &#39;unsupported tags type {}&#39;.format(type(tags)),
            type=RelationalTagError.TYPE_WRONG_TYPE
        )
    
    return cls.all_tags.values()</code></pre>
</details>
</dd>
<dt id="relational_tags.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>name: str, get_if_exists: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = RelationalTag(name=name)
        return rtag
    
    except RelationalTagError as e:
        cls.log.warning(str(e))
        
        if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
            return cls.all_tags[name]
        else:
            raise e
    # end except</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="relational_tags.RelationalTag"><code class="flex name class">
<span>class <span class="ident">RelationalTag</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Relational tag class.</p>
<p>A relational tag can be connected to an entity to categorize it, and also be connected to other
relational tags.</p>
<p>RelationalTag constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalTag:
    &#34;&#34;&#34;Relational tag class.
    
    A relational tag can be connected to an entity to categorize it, and also be connected to other
    relational tags.
    &#34;&#34;&#34;
    
    log:Logger = logging.getLogger(&#39;{}.RelationalTag&#39;.format(__name__))
    
    _is_case_sensitive:bool = False
    &#34;&#34;&#34;Whether tag uniqueness is case-sensitive.
    
    **default** `False`
    &#34;&#34;&#34;
    
    all_tags:Dict[str, &#39;RelationalTag&#39;] = {}
    &#34;&#34;&#34;All relational tags.&#34;&#34;&#34;
    
    _tagged_entities:Dict[Any, Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]] = {}
    &#34;&#34;&#34;All entities that have been assigned tags.
    
    Connections dict key per entity is equal to the connection&#39;s `target`.
    &#34;&#34;&#34;
    
    @classmethod
    def config(cls, is_case_sensitive:bool=False):
        &#34;&#34;&#34;RelationalTag static config.
        &#34;&#34;&#34;
        
        cls._is_case_sensitive = is_case_sensitive
    # end config
    
    @classmethod
    def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = RelationalTag(name=name)
            return rtag
        
        except RelationalTagError as e:
            cls.log.warning(str(e))
            
            if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
                return cls.all_tags[name]
            else:
                raise e
        # end except
    # end new
    
    @classmethod
    def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = cls.all_tags[name]
            return rtag
            
        except KeyError as e:
            cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
            
            if new_if_missing:
                rtag = RelationalTag(name=name)
                return rtag
            else:
                raise RelationalTagError(
                    &#39;tag {} missing&#39;.format(name), 
                    RelationalTagError.TYPE_MISSING
                )
        # end except
    # end get
    
    @classmethod
    def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
        try:
            # convert tag to RelationalTag
            if isinstance(tag,str):
                if not cls._is_case_sensitive:
                    tag = tag.lower()
                
                tag = cls.all_tags[tag]
            # end if not RelationalTag
            
            cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
            
            # delete references from others
            for connection in tag.connections.values():
                other = connection.source
                
                if isinstance(other, RelationalTag):
                    # disconnect from other tag
                    del other.connections[tag]
                
                else:
                    # disconnect from entity
                    del _tagged_entities[other][tag]
            # end for connection in connections
            
            # delete tag
            del cls.all_tags[tag.name]
        
        except KeyError as e:
            cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))
    # end delete
    
    @classmethod
    def clear(cls) -&gt; int:
        num_tags = len(cls.all_tags)
        
        cls.all_tags = {}
        cls._tagged_entities = {}
        
        return num_tags
    # end clear
    
    @classmethod
    def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
        &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
        
        There are multiple ways to define a relational tags system:
        
        ## From Save
        
        Pass a list of `RelationalTag` instances as the `tags` arg.
        
        ## Flat
        
        Pass a list of tag name strings. Tags will not have any relationships with each other.
        Repeated tag names are allowed.
        
        Example:
        
        ```
        [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
        ```
        
        ## Hierarchy
        
        Pass a dict, where each key is a tag name string, and each value is either a single
        tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
        
        Example:
        
        ```
        {
            &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
            &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
            &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
            &#39;sport&#39;: &#39;football&#39;
        }
        ```
        
        ## Args
        
        **tags** Relational tags, either as a list or dict. Entities not supported.
        
        **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
        of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
        `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if isinstance(tags, List):
            for tag in tags:
                if isinstance(tag,RelationalTag):
                    if tag in all_tags:
                        log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                    
                    all_tags[tag.name] = tag
                
                elif isinstance(tag,str):
                    cls.new(tag, get_if_exists=True)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported tag type {}&#39;.format(type(tag)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag in tags
            
        elif isinstance(tags, Dict):
            for tag, value in tags.items():
                # create new parent tag
                rtag = cls.new(tag, get_if_exists=True)
                
                if isinstance(value,List):
                    # tag to many
                    for val in value:
                        ttag = cls.get(val, new_if_missing=True)
                        cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
                
                elif isinstance(value,str):
                    # tag to one
                    ttag = cls.get(value, new_if_missing=True)
                    cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported target type {}&#39;.format(type(value)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag,value in tags
            
        else:
            raise RelationalTagError(
                &#39;unsupported tags type {}&#39;.format(type(tags)),
                type=RelationalTagError.TYPE_WRONG_TYPE
            )
        
        return cls.all_tags.values()
    # end load
    
    @classmethod
    def _entity_to_hashable(cls,entity:Any) -&gt; Union[HashableEntity,Any]:
        &#34;&#34;&#34;Wraps the entity in a `HashableEntity` instance if not hashable already.
        &#34;&#34;&#34;
        
        if &#39;__hash__&#39; in dir(entity) and entity.__hash__ is not None:
            return entity
        
        else:
            return HashableEntity(entity)
    # end _entity_to_hashable
    
    @classmethod
    def _hashable_to_entity(cls,entity:Union[HashableEntity,Any]) -&gt; Any:
        if isinstance(entity,HashableEntity):
            return entity.entity
        
        else:
            return entity
    # end _hashable_to_entity
    
    @classmethod
    def connect(cls, tag:&#39;RelationalTag&#39;, target:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Connect a tag with a target.
        &#34;&#34;&#34;
        
        # resolve connection type
        if connection_type is None:
            if isinstance(target,RelationalTag):
                connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
            else:
                connection_type = RelationalTagConnection.TO_ENT
        
        # connection
        connection = RelationalTagConnection(
            source=tag,
            target=target,
            connection_type=connection_type
        )
        tag.connections[cls._entity_to_hashable(target)] = connection
        
        # inverse connection
        inverse_connection = connection.inverse()
        if isinstance(target,RelationalTag):
            # tag connection
            target.connections[tag] = inverse_connection
        else:
            # entity connection
            entity = cls._entity_to_hashable(target)
            
            if not entity in cls._tagged_entities:
                cls._tagged_entities[entity] = {}
            
            cls._tagged_entities[entity][tag] = inverse_connection
        
        # return
        return connection
    # end connect
    
    @classmethod
    def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
        &#34;&#34;&#34;Disconnect a tag from a target.
        
        ## Args
        
        **tag_or_connection** Either a relational tag source, or the connection that contains info
        about both the source and the target.
        
        **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
        &#34;&#34;&#34;
        
        if isinstance(tag_or_connection, RelationalTagConnection):
            # disconnect connection
            cls.disconnect(tag_or_connection.source, tag_or_connection.target)
        
        else:
            hashable_target = cls._entity_to_hashable(target)
            
            # disconnect tag-target
            del tag.connections[hashable_target]
            
            # TODO here, then finish RelationalTag.load
            if isinstance(target,RelationalTag):
                # tag connection
                # disconnect target-tag
                del target.connections[tag]
            
            else:
                # entity connection
                # disconnect target-tag
                if hashable_target in _tagged_entities:
                    del _tagged_entities[hashable_target][tag]
                    
                else:
                    log.warning(&#39;entity {} already untagged&#39;.format(target))
    # end connect
    
    @classmethod
    def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
        tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
        
        for relational_entity,connections in cls._tagged_entities.items():
            raw_entity = cls._hashable_to_entity(relational_entity)
            tagged_entities.append((raw_entity, connections))
        
        return tagged_entities
    # end get_tagged_entities
    
    def __init__(self, name:str):
        &#34;&#34;&#34;RelationalTag constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if not cls._is_case_sensitive:
            name = name.lower()
        
        if name in cls.all_tags:
            raise RelationalTagError(&#39;tag {} already exists&#39;.format(name))
        
        else:
            self.name = name
            &#34;&#34;&#34;Tag name.
            &#34;&#34;&#34;
            
            self.connections:Dict[Union[RelationalTag,Any], RelationalTagConnection] = {}
            &#34;&#34;&#34;Tag connections (relationships).
            
            Connection keys are equal to `RelationalTagConnection.target`.
            &#34;&#34;&#34;
            
            cls.all_tags[self.name] = self
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTag string representation.
        &#34;&#34;&#34;
        
        return &#39;{}[{}]&#39;.format(
            self.name,
            &#39; &#39;.join([str(conn) for conn in self.connections.values()])
        )
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTag) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash(self.name)
    # end __hash__
    
    def connect_to(self, other:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None):
        &#34;&#34;&#34;Connect tag to another tag or entity.
        
        Calls the class method `RelationalTag.connect`.
        &#34;&#34;&#34;
        
        type(self).connect(tag=self,target=other,connection_type=connection_type)
    # end connect_to
    
    def disconnect_to(self, other:Union[&#39;RelationalTag&#39;,Any]):
        &#34;&#34;&#34;Disconnect tag from another tag or entity.
        
        Calls the class method `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        type(self).disconnect(tag=self,target=other)
    # end disconnect_to
    
    def delete_self(self):
        type(self).delete(self)
    # end delete</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalTag.all_tags"><code class="name">var <span class="ident">all_tags</span> : Dict[str, <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</code></dt>
<dd>
<div class="desc"><p>All relational tags.</p></div>
</dd>
<dt id="relational_tags.RelationalTag.log"><code class="name">var <span class="ident">log</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="relational_tags.RelationalTag.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clear(cls) -&gt; int:
    num_tags = len(cls.all_tags)
    
    cls.all_tags = {}
    cls._tagged_entities = {}
    
    return num_tags</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>is_case_sensitive: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>RelationalTag static config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def config(cls, is_case_sensitive:bool=False):
    &#34;&#34;&#34;RelationalTag static config.
    &#34;&#34;&#34;
    
    cls._is_case_sensitive = is_case_sensitive</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>tag: <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any], connection_type: int = None) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a tag with a target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def connect(cls, tag:&#39;RelationalTag&#39;, target:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Connect a tag with a target.
    &#34;&#34;&#34;
    
    # resolve connection type
    if connection_type is None:
        if isinstance(target,RelationalTag):
            connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
        else:
            connection_type = RelationalTagConnection.TO_ENT
    
    # connection
    connection = RelationalTagConnection(
        source=tag,
        target=target,
        connection_type=connection_type
    )
    tag.connections[cls._entity_to_hashable(target)] = connection
    
    # inverse connection
    inverse_connection = connection.inverse()
    if isinstance(target,RelationalTag):
        # tag connection
        target.connections[tag] = inverse_connection
    else:
        # entity connection
        entity = cls._entity_to_hashable(target)
        
        if not entity in cls._tagged_entities:
            cls._tagged_entities[entity] = {}
        
        cls._tagged_entities[entity][tag] = inverse_connection
    
    # return
    return connection</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>tag: Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
    try:
        # convert tag to RelationalTag
        if isinstance(tag,str):
            if not cls._is_case_sensitive:
                tag = tag.lower()
            
            tag = cls.all_tags[tag]
        # end if not RelationalTag
        
        cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
        
        # delete references from others
        for connection in tag.connections.values():
            other = connection.source
            
            if isinstance(other, RelationalTag):
                # disconnect from other tag
                del other.connections[tag]
            
            else:
                # disconnect from entity
                del _tagged_entities[other][tag]
        # end for connection in connections
        
        # delete tag
        del cls.all_tags[tag.name]
    
    except KeyError as e:
        cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>tag_or_connection: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), ForwardRef('<a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>')], target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect a tag from a target.</p>
<h2 id="args">Args</h2>
<p><strong>tag_or_connection</strong> Either a relational tag source, or the connection that contains info
about both the source and the target.</p>
<p><strong>target</strong> Connection target, or <code>None</code> if a connection was provided for <code>tag_or_connection</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
    &#34;&#34;&#34;Disconnect a tag from a target.
    
    ## Args
    
    **tag_or_connection** Either a relational tag source, or the connection that contains info
    about both the source and the target.
    
    **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
    &#34;&#34;&#34;
    
    if isinstance(tag_or_connection, RelationalTagConnection):
        # disconnect connection
        cls.disconnect(tag_or_connection.source, tag_or_connection.target)
    
    else:
        hashable_target = cls._entity_to_hashable(target)
        
        # disconnect tag-target
        del tag.connections[hashable_target]
        
        # TODO here, then finish RelationalTag.load
        if isinstance(target,RelationalTag):
            # tag connection
            # disconnect target-tag
            del target.connections[tag]
        
        else:
            # entity connection
            # disconnect target-tag
            if hashable_target in _tagged_entities:
                del _tagged_entities[hashable_target][tag]
                
            else:
                log.warning(&#39;entity {} already untagged&#39;.format(target))</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name: str, new_if_missing: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = cls.all_tags[name]
        return rtag
        
    except KeyError as e:
        cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
        
        if new_if_missing:
            rtag = RelationalTag(name=name)
            return rtag
        else:
            raise RelationalTagError(
                &#39;tag {} missing&#39;.format(name), 
                RelationalTagError.TYPE_MISSING
            )
    # end except</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.get_tagged_entities"><code class="name flex">
<span>def <span class="ident">get_tagged_entities</span></span>(<span>) ‑> List[Tuple[Any, Dict[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
    tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
    
    for relational_entity,connections in cls._tagged_entities.items():
        raw_entity = cls._hashable_to_entity(relational_entity)
        tagged_entities.append((raw_entity, connections))
    
    return tagged_entities</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>tags: Union[List[Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')]], Dict[str, Union[str, List[str]]]], tag_tag_type: int = 'RelationalTagConnection.TO_TAG_CHILD') ‑> List[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a set of tags, including optional connection info for each.</p>
<p>There are multiple ways to define a relational tags system:</p>
<h2 id="from-save">From Save</h2>
<p>Pass a list of <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code> instances as the <code>tags</code> arg.</p>
<h2 id="flat">Flat</h2>
<p>Pass a list of tag name strings. Tags will not have any relationships with each other.
Repeated tag names are allowed.</p>
<p>Example:</p>
<pre><code>['apple','banana','cinnamon','donut']
</code></pre>
<h2 id="hierarchy">Hierarchy</h2>
<p>Pass a dict, where each key is a tag name string, and each value is either a single
tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.</p>
<p>Example:</p>
<pre><code>{
    'fruit': ['apple','banana','orange'],
    'food': ['fruit','vegetable'],
    'color': ['red','blue','green','orange'],
    'sport': 'football'
}
</code></pre>
<h2 id="args">Args</h2>
<p><strong>tags</strong> Relational tags, either as a list or dict. Entities not supported.</p>
<p><strong>tag_tag_type</strong> Specify what a key-value relationship in a dictionary means. Default
of <code><a title="relational_tags.RelationalTagConnection.TO_TAG_CHILD" href="#relational_tags.RelationalTagConnection.TO_TAG_CHILD">RelationalTagConnection.TO_TAG_CHILD</a></code> means the key is the parent of the value. See
<code>RelationalTagConnection._TAG_TAG_TYPES</code> for possible values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
    &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
    
    There are multiple ways to define a relational tags system:
    
    ## From Save
    
    Pass a list of `RelationalTag` instances as the `tags` arg.
    
    ## Flat
    
    Pass a list of tag name strings. Tags will not have any relationships with each other.
    Repeated tag names are allowed.
    
    Example:
    
    ```
    [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
    ```
    
    ## Hierarchy
    
    Pass a dict, where each key is a tag name string, and each value is either a single
    tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
    
    Example:
    
    ```
    {
        &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
        &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
        &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
        &#39;sport&#39;: &#39;football&#39;
    }
    ```
    
    ## Args
    
    **tags** Relational tags, either as a list or dict. Entities not supported.
    
    **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
    of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
    `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
    &#34;&#34;&#34;
    
    if isinstance(tags, List):
        for tag in tags:
            if isinstance(tag,RelationalTag):
                if tag in all_tags:
                    log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                
                all_tags[tag.name] = tag
            
            elif isinstance(tag,str):
                cls.new(tag, get_if_exists=True)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported tag type {}&#39;.format(type(tag)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag in tags
        
    elif isinstance(tags, Dict):
        for tag, value in tags.items():
            # create new parent tag
            rtag = cls.new(tag, get_if_exists=True)
            
            if isinstance(value,List):
                # tag to many
                for val in value:
                    ttag = cls.get(val, new_if_missing=True)
                    cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
            
            elif isinstance(value,str):
                # tag to one
                ttag = cls.get(value, new_if_missing=True)
                cls.connect(tag=rtag, target=ttag, connection_type=tag_tag_type)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported target type {}&#39;.format(type(value)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag,value in tags
        
    else:
        raise RelationalTagError(
            &#39;unsupported tags type {}&#39;.format(type(tags)),
            type=RelationalTagError.TYPE_WRONG_TYPE
        )
    
    return cls.all_tags.values()</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>name: str, get_if_exists: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = RelationalTag(name=name)
        return rtag
    
    except RelationalTagError as e:
        cls.log.warning(str(e))
        
        if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
            return cls.all_tags[name]
        else:
            raise e
    # end except</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="relational_tags.RelationalTag.connect_to"><code class="name flex">
<span>def <span class="ident">connect_to</span></span>(<span>self, other: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any], connection_type: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect tag to another tag or entity.</p>
<p>Calls the class method <code><a title="relational_tags.RelationalTag.connect" href="#relational_tags.RelationalTag.connect">RelationalTag.connect()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_to(self, other:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None):
    &#34;&#34;&#34;Connect tag to another tag or entity.
    
    Calls the class method `RelationalTag.connect`.
    &#34;&#34;&#34;
    
    type(self).connect(tag=self,target=other,connection_type=connection_type)</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.delete_self"><code class="name flex">
<span>def <span class="ident">delete_self</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_self(self):
    type(self).delete(self)</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.disconnect_to"><code class="name flex">
<span>def <span class="ident">disconnect_to</span></span>(<span>self, other: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect tag from another tag or entity.</p>
<p>Calls the class method <code><a title="relational_tags.RelationalTag.disconnect" href="#relational_tags.RelationalTag.disconnect">RelationalTag.disconnect()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_to(self, other:Union[&#39;RelationalTag&#39;,Any]):
    &#34;&#34;&#34;Disconnect tag from another tag or entity.
    
    Calls the class method `RelationalTag.disconnect`.
    &#34;&#34;&#34;
    
    type(self).disconnect(tag=self,target=other)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="relational_tags.RelationalTagConnection"><code class="flex name class">
<span>class <span class="ident">RelationalTagConnection</span></span>
<span>(</span><span>source: <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, target: Union[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, Any], connection_type=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Relational tag connection.</p>
<p>RelationalTagConnection constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalTagConnection:
    &#34;&#34;&#34;Relational tag connection.
    &#34;&#34;&#34;
    
    log:logging.Logger = logging.getLogger(&#39;{}.RelationalTagConnection&#39;.format(__name__))
    
    TO_TAG_UNDIRECTED:int = 1
    &#34;&#34;&#34;Undirected tag-tag connection.&#34;&#34;&#34;
    TO_TAG_PARENT:int = 2
    &#34;&#34;&#34;Child-parent tag-tag connection.&#34;&#34;&#34;
    TO_TAG_CHILD:int = 3
    &#34;&#34;&#34;Parent-child tag-tag connection.&#34;&#34;&#34;
    TO_ENT:int = 4
    &#34;&#34;&#34;Tag-entity connection.&#34;&#34;&#34;
    ENT_TO_TAG:int = 5
    &#34;&#34;&#34;Entity-tag connection.&#34;&#34;&#34;
    
    _TAG_TAG_TYPES:List[int] = [TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD]
    &#34;&#34;&#34;All tag-tag connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    &#34;&#34;&#34;
    
    _TAG_ENT_TYPES:List[int] = [TO_ENT,ENT_TO_TAG]
    &#34;&#34;&#34;All tag-entity connection types.
    
    ## Items
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    _TYPES:List[int] = [
        TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD,TO_ENT,ENT_TO_TAG
    ]
    &#34;&#34;&#34;All connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    @classmethod
    def type_to_str(cls,type:int) -&gt; str:
        if type == cls.TO_TAG_UNDIRECTED:
            return &#39;to-tag-undirected&#39;
        
        elif type == cls.TO_TAG_PARENT:
            return &#39;to-tag-parent&#39;
        
        elif type == cls.TO_TAG_CHILD:
            return &#39;to-tag-child&#39;
            
        elif type == cls.TO_ENT:
            return &#39;to-entity&#39;
            
        elif type == cls.ENT_TO_TAG:
            return &#39;entity-to-tag&#39;
    # end type_to_str
    
    @classmethod
    def inverse_type(cls,type:int) -&gt; int:
        if type == cls.TO_TAG_PARENT:
            return cls.TO_TAG_CHILD
        
        elif type == cls.TO_TAG_CHILD:
            return cls.TO_TAG_PARENT
        
        elif type == cls.TO_ENT:
            return cls.ENT_TO_TAG
            
        elif type == cls.ENT_TO_TAG:
            return cls.TO_ENT
            
        else:
            return type
    # end reverse_type
    
    def __init__(self, source:RelationalTag, target:Union[RelationalTag,Any], connection_type=TO_ENT):
        &#34;&#34;&#34;RelationalTagConnection constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        self.source:RelationalTag = source
        &#34;&#34;&#34;Connection source; must be a `RelationalTag`.
        &#34;&#34;&#34;
        
        self.target:Union[RelationalTag,Any] = target
        &#34;&#34;&#34;Connection target; either a `RelationalTag`, or an entity.
        &#34;&#34;&#34;
        
        self.type = connection_type
        &#34;&#34;&#34;Connection type. See `_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if self.type in cls._TAG_TAG_TYPES and not isinstance(target,RelationalTag):
            raise RelationalTagError(
                &#39;cannot create {} connection with non-tag {}&#39;.format(
                    cls.type_to_str(self.type),
                    target
                ),
                RelationalTagError.TYPE_WRONG_TYPE
            )
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTagConnection string representation.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if isinstance(self.source,RelationalTag):
            source_str = self.source.name
        else:
            source_str = self.source
        
        if isinstance(self.target,RelationalTag):
            target_str = self.target.name
        else:
            target_str = self.target
        
        return &#39;{}={}={}&#39;.format(source_str,cls.type_to_str(self.type),target_str)
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTagConnection) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash((self.source, self.target, self.type))
    # end __hash__
    
    def inverse(self) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Return inverse connection.
        &#34;&#34;&#34;
        
        return RelationalTagConnection(
            source=self.target,
            target=self.source,
            connection_type=type(self).inverse_type(self.type)
        )
    # end inverse
    
    def disconnect(self):
        &#34;&#34;&#34;Disconnect source and target.
        
        Convenience method for `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        RelationalTag.disconnect(tag_or_connection=self)
    # end disconnect</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.ENT_TO_TAG"><code class="name">var <span class="ident">ENT_TO_TAG</span> : int</code></dt>
<dd>
<div class="desc"><p>Entity-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_ENT"><code class="name">var <span class="ident">TO_ENT</span> : int</code></dt>
<dd>
<div class="desc"><p>Tag-entity connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_TAG_CHILD"><code class="name">var <span class="ident">TO_TAG_CHILD</span> : int</code></dt>
<dd>
<div class="desc"><p>Parent-child tag-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_TAG_PARENT"><code class="name">var <span class="ident">TO_TAG_PARENT</span> : int</code></dt>
<dd>
<div class="desc"><p>Child-parent tag-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_TAG_UNDIRECTED"><code class="name">var <span class="ident">TO_TAG_UNDIRECTED</span> : int</code></dt>
<dd>
<div class="desc"><p>Undirected tag-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.log"><code class="name">var <span class="ident">log</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.inverse_type"><code class="name flex">
<span>def <span class="ident">inverse_type</span></span>(<span>type: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def inverse_type(cls,type:int) -&gt; int:
    if type == cls.TO_TAG_PARENT:
        return cls.TO_TAG_CHILD
    
    elif type == cls.TO_TAG_CHILD:
        return cls.TO_TAG_PARENT
    
    elif type == cls.TO_ENT:
        return cls.ENT_TO_TAG
        
    elif type == cls.ENT_TO_TAG:
        return cls.TO_ENT
        
    else:
        return type</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTagConnection.type_to_str"><code class="name flex">
<span>def <span class="ident">type_to_str</span></span>(<span>type: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def type_to_str(cls,type:int) -&gt; str:
    if type == cls.TO_TAG_UNDIRECTED:
        return &#39;to-tag-undirected&#39;
    
    elif type == cls.TO_TAG_PARENT:
        return &#39;to-tag-parent&#39;
    
    elif type == cls.TO_TAG_CHILD:
        return &#39;to-tag-child&#39;
        
    elif type == cls.TO_ENT:
        return &#39;to-entity&#39;
        
    elif type == cls.ENT_TO_TAG:
        return &#39;entity-to-tag&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.source"><code class="name">var <span class="ident">source</span></code></dt>
<dd>
<div class="desc"><p>Connection source; must be a <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code>.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.target"><code class="name">var <span class="ident">target</span></code></dt>
<dd>
<div class="desc"><p>Connection target; either a <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code>, or an entity.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Connection type. See <code>_TYPES</code> for possible values.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect source and target.</p>
<p>Convenience method for <code><a title="relational_tags.RelationalTag.disconnect" href="#relational_tags.RelationalTag.disconnect">RelationalTag.disconnect()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect source and target.
    
    Convenience method for `RelationalTag.disconnect`.
    &#34;&#34;&#34;
    
    RelationalTag.disconnect(tag_or_connection=self)</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTagConnection.inverse"><code class="name flex">
<span>def <span class="ident">inverse</span></span>(<span>self) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return inverse connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse(self) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Return inverse connection.
    &#34;&#34;&#34;
    
    return RelationalTagConnection(
        source=self.target,
        target=self.source,
        connection_type=type(self).inverse_type(self.type)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="relational_tags.RelationalTagError"><code class="flex name class">
<span>class <span class="ident">RelationalTagError</span></span>
<span>(</span><span>message, type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Relational tag error.</p>
<p>RelationalTagError constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalTagError(Exception):
    &#34;&#34;&#34;Relational tag error.
    &#34;&#34;&#34;
    
    TYPE_COLLISION = 1
    TYPE_MISSING = 2
    TYPE_WRONG_TYPE = 3
    TYPE_HASH_FAIL = 4
    
    def __init__(self, message, type=TYPE_COLLISION):
        &#34;&#34;&#34;RelationalTagError constructor.
        &#34;&#34;&#34;
        
        super().__init__(message)
        
        self.type = type
    # end __init__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalTagError.TYPE_COLLISION"><code class="name">var <span class="ident">TYPE_COLLISION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_HASH_FAIL"><code class="name">var <span class="ident">TYPE_HASH_FAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_MISSING"><code class="name">var <span class="ident">TYPE_MISSING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_WRONG_TYPE"><code class="name">var <span class="ident">TYPE_WRONG_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="relational_tags.VERSION" href="#relational_tags.VERSION">VERSION</a></code></li>
<li><code><a title="relational_tags.all_tags" href="#relational_tags.all_tags">all_tags</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="relational_tags.clear" href="#relational_tags.clear">clear</a></code></li>
<li><code><a title="relational_tags.config" href="#relational_tags.config">config</a></code></li>
<li><code><a title="relational_tags.connect" href="#relational_tags.connect">connect</a></code></li>
<li><code><a title="relational_tags.delete" href="#relational_tags.delete">delete</a></code></li>
<li><code><a title="relational_tags.disconnect" href="#relational_tags.disconnect">disconnect</a></code></li>
<li><code><a title="relational_tags.get" href="#relational_tags.get">get</a></code></li>
<li><code><a title="relational_tags.load" href="#relational_tags.load">load</a></code></li>
<li><code><a title="relational_tags.new" href="#relational_tags.new">new</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code></h4>
<ul class="two-column">
<li><code><a title="relational_tags.RelationalTag.all_tags" href="#relational_tags.RelationalTag.all_tags">all_tags</a></code></li>
<li><code><a title="relational_tags.RelationalTag.clear" href="#relational_tags.RelationalTag.clear">clear</a></code></li>
<li><code><a title="relational_tags.RelationalTag.config" href="#relational_tags.RelationalTag.config">config</a></code></li>
<li><code><a title="relational_tags.RelationalTag.connect" href="#relational_tags.RelationalTag.connect">connect</a></code></li>
<li><code><a title="relational_tags.RelationalTag.connect_to" href="#relational_tags.RelationalTag.connect_to">connect_to</a></code></li>
<li><code><a title="relational_tags.RelationalTag.delete" href="#relational_tags.RelationalTag.delete">delete</a></code></li>
<li><code><a title="relational_tags.RelationalTag.delete_self" href="#relational_tags.RelationalTag.delete_self">delete_self</a></code></li>
<li><code><a title="relational_tags.RelationalTag.disconnect" href="#relational_tags.RelationalTag.disconnect">disconnect</a></code></li>
<li><code><a title="relational_tags.RelationalTag.disconnect_to" href="#relational_tags.RelationalTag.disconnect_to">disconnect_to</a></code></li>
<li><code><a title="relational_tags.RelationalTag.get" href="#relational_tags.RelationalTag.get">get</a></code></li>
<li><code><a title="relational_tags.RelationalTag.get_tagged_entities" href="#relational_tags.RelationalTag.get_tagged_entities">get_tagged_entities</a></code></li>
<li><code><a title="relational_tags.RelationalTag.load" href="#relational_tags.RelationalTag.load">load</a></code></li>
<li><code><a title="relational_tags.RelationalTag.log" href="#relational_tags.RelationalTag.log">log</a></code></li>
<li><code><a title="relational_tags.RelationalTag.new" href="#relational_tags.RelationalTag.new">new</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></code></h4>
<ul class="two-column">
<li><code><a title="relational_tags.RelationalTagConnection.ENT_TO_TAG" href="#relational_tags.RelationalTagConnection.ENT_TO_TAG">ENT_TO_TAG</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_ENT" href="#relational_tags.RelationalTagConnection.TO_ENT">TO_ENT</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_TAG_CHILD" href="#relational_tags.RelationalTagConnection.TO_TAG_CHILD">TO_TAG_CHILD</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_TAG_PARENT" href="#relational_tags.RelationalTagConnection.TO_TAG_PARENT">TO_TAG_PARENT</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_TAG_UNDIRECTED" href="#relational_tags.RelationalTagConnection.TO_TAG_UNDIRECTED">TO_TAG_UNDIRECTED</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.disconnect" href="#relational_tags.RelationalTagConnection.disconnect">disconnect</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.inverse" href="#relational_tags.RelationalTagConnection.inverse">inverse</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.inverse_type" href="#relational_tags.RelationalTagConnection.inverse_type">inverse_type</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.log" href="#relational_tags.RelationalTagConnection.log">log</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.source" href="#relational_tags.RelationalTagConnection.source">source</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.target" href="#relational_tags.RelationalTagConnection.target">target</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.type" href="#relational_tags.RelationalTagConnection.type">type</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.type_to_str" href="#relational_tags.RelationalTagConnection.type_to_str">type_to_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="relational_tags.RelationalTagError" href="#relational_tags.RelationalTagError">RelationalTagError</a></code></h4>
<ul class="">
<li><code><a title="relational_tags.RelationalTagError.TYPE_COLLISION" href="#relational_tags.RelationalTagError.TYPE_COLLISION">TYPE_COLLISION</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_HASH_FAIL" href="#relational_tags.RelationalTagError.TYPE_HASH_FAIL">TYPE_HASH_FAIL</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_MISSING" href="#relational_tags.RelationalTagError.TYPE_MISSING">TYPE_MISSING</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_WRONG_TYPE" href="#relational_tags.RelationalTagError.TYPE_WRONG_TYPE">TYPE_WRONG_TYPE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>