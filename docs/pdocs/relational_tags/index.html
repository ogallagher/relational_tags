<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>relational_tags API documentation</title>
<meta name="description" content="Relational tagging package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>relational_tags</code></h1>
</header>
<section id="section-intro">
<p>Relational tagging package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Owen Gallagher
# 13 June 2021

&#34;&#34;&#34;Relational tagging package.
&#34;&#34;&#34;

# imports

from typing import List, Dict, Union, Any, Tuple, Type
import logging
from logging import Logger
import json

# module vars

VERSION:str = &#39;0.0.6&#39;
&#34;&#34;&#34;Package version.
&#34;&#34;&#34;

# types

class HashableEntity:
    &#34;&#34;&#34;If an entity is not hashable, it is wrapped automatically with this class.
    
    You should not need to use this class yourself.
    
    If you want to create entities that have full support for relational tagging, 
    including being saved to a relational tags file and loaded from one, see
    `RelationalEntity`.
    &#34;&#34;&#34;
    
    def __init__(self, entity:Any):
        try:
            self.hash = hash(&#39;{}@{}&#39;.format(type(entity),id(entity)))
            &#34;&#34;&#34;Hash value, using the type and memory address of the entity.
            &#34;&#34;&#34;
        
            self.entity = entity
            &#34;&#34;&#34;Entity value.&#34;&#34;&#34;
            
        except:
            raise RelationalTagError(
                &#39;unable to create relational entity from {}&#39;.format(entity),
                RelationalTagError.TYPE_HASH_FAIL
            )
    # end __init__
    
    def __eq__(self, other:Any) -&gt; bool:
        if isinstance(other,HashableEntity):
            return self.hash == other.hash
        
        if &#39;__hash__&#39; not in dir(other) or entity.__hash__ is None:
            return self.hash == HashableEntity(other).hash
        
        else:
            return False
    # end __eq__
    
    def __hash__(self):
        return self.hash
    # end __hash__
# end HashableEntity

class RelationalEntity:
    &#34;&#34;&#34;Relational entity abstract class.
    
    Subclass this abstract class and implement the required methods in order to 
    define an entity that is fully compatible with relational tagging.
    
    Note it is not necessary to use RelationalEntity subclasses in order to 
    use relational tagging; anything can be an entity and can be tagged. However, 
    subclasses if `RelationalEntity` are required in order to include them in the
    built-in persistence methods provided: `save_json`, `load_json`.
    &#34;&#34;&#34;
    
    _ATTR_CLASS:str = &#39;class&#39;
    
    classes:Dict[str,Type[&#39;RelationalEntity&#39;]] = {}
    &#34;&#34;&#34;Maintains a name-class dictionary for identifying serialized subclass instances.
    
    Sublasses of `RelationalEntity` are automatically added to this dictionary with
    `RelationalEntity.__init__`.
    &#34;&#34;&#34;
    
    @classmethod
    def load_entity(cls, entity_json:Union[str,Dict]) -&gt; &#39;RelationalEntity&#39;:
        &#34;&#34;&#34;A relational entity must be able to deserialize itself.
        
        Note this method will be used to deserialize an entity from its json string
        representation, or equivalent python dict.
        
        ## Args
        
        **entity_json** Either a json representation of the entity (created from 
        `RelaionalEntity.__str__`, or an equivalent python dict)
        &#34;&#34;&#34;
        
        raise NotImplementedError(
            &#39;RelationalEntity is an abstract class; subclass implements load_entity&#39;
        )
    # end load_entity
    
    def __init__(self):
        &#34;&#34;&#34;## RelationalEntity constructor.
        
        A subclass with its own constructor should call this superconstructor with:
        
        ```
        super().__init__()
        ```
        
        or implement equivalent code in its own constructor.
        &#34;&#34;&#34;
        
        cls_name = RelationalEntity.__name__
        if cls_name not in RelationalEntity.classes:
            RelationalEntity.classes[cls_name] = RelationalEntity
        
        subcls = type(self)
        RelationalEntity.classes[subcls.__name__] = subcls
    # end __init__
    
    def __hash__(self):
        &#34;&#34;&#34;A relational entity must be hashable.
        
        This method will be used to check equivalence between different entities and
        to use them as dictionary keys for quick access.
        &#34;&#34;&#34;
        
        raise NotImplementedError(
            &#39;RelationalEntity is an abstract class; subclass implements __hash__&#39;
        )
    # end __hash__
    
    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Default implementation of equality.
        
        You should not need to override this method unless you want more strict equality
        checking.
        &#34;&#34;&#34;
        
        return hash(self) == hash(other)
    # end __eq__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;A relational entity must be able to serialize itself.
        
        Note this method will be used to serialize this instance so that it can be included
        in a relational tags json save file.
        
        ## Requirements
        
        Compatible with overridden `RelationalEntity.load_entity`.
        
        The resultant string is valid json.
        
        The json string represents a dictionary with the following initial structure:
        
        ```
        {
            &#34;class&#34;: &#34;&lt;class-name&gt;&#34;  # &lt;class-name&gt; = type(self).__name__
        }
        ```
        &#34;&#34;&#34;
        
        raise NotImplementedError(
            &#39;RelationalEntity is an abstract class; subclass implements __str__&#39;
        )
    # end __str__
# end RelationalEntity

class RelationalTag:
    &#34;&#34;&#34;Relational tag class.
    
    A relational tag can be connected to an entity to categorize it, and also be connected to other
    relational tags.
    &#34;&#34;&#34;
    
    log:Logger = logging.getLogger(&#39;{}.RelationalTag&#39;.format(__name__))
    
    _is_case_sensitive:bool = False
    &#34;&#34;&#34;Whether tag uniqueness is case-sensitive.
    
    **default** `False`
    &#34;&#34;&#34;
    
    all_tags:Dict[str, &#39;RelationalTag&#39;] = {}
    &#34;&#34;&#34;All relational tags.&#34;&#34;&#34;
    
    _tagged_entities:Dict[Any, Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]] = {}
    &#34;&#34;&#34;All entities that have been assigned tags.
    
    Connections dict key per entity is equal to the connection&#39;s `target`.
    &#34;&#34;&#34;
    
    @classmethod
    def config(cls, is_case_sensitive:bool=False):
        &#34;&#34;&#34;Initial configuration.
        
        ## Configured variables
        
        `RelationalTag._is_case_sensitive`
        &#34;&#34;&#34;
        
        cls._is_case_sensitive = is_case_sensitive
    # end config
    
    @classmethod
    def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = RelationalTag(name=name)
            return rtag
        
        except RelationalTagError as e:
            cls.log.warning(str(e))
            
            if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
                return cls.all_tags[name]
            else:
                raise e
        # end except
    # end new
    
    @classmethod
    def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = cls.all_tags[name]
            return rtag
            
        except KeyError as e:
            cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
            
            if new_if_missing:
                rtag = RelationalTag(name=name)
                return rtag
            else:
                raise RelationalTagError(
                    &#39;tag {} missing&#39;.format(name), 
                    RelationalTagError.TYPE_MISSING
                )
        # end except
    # end get
    
    @classmethod
    def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
        try:
            # convert tag to RelationalTag
            if isinstance(tag,str):
                if not cls._is_case_sensitive:
                    tag = tag.lower()
                
                tag = cls.all_tags[tag]
            # end if not RelationalTag
            
            cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
            
            # delete references from others
            for connection in tag.connections.values():
                other = connection.target
                
                if isinstance(other, RelationalTag):
                    # disconnect from other tag
                    del other.connections[tag]
                
                else:
                    # disconnect from entity
                    del cls._tagged_entities[cls._entity_to_hashable(other)][tag]
            # end for connection in connections
            
            # delete tag
            del cls.all_tags[tag.name]
        
        except KeyError as e:
            cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))
    # end delete
    
    @classmethod
    def clear(cls) -&gt; int:
        num_tags = len(cls.all_tags)
        
        cls.all_tags = {}
        cls._tagged_entities = {}
        
        return num_tags
    # end clear
    
    @classmethod
    def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
        &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
        
        There are multiple ways to define a relational tags system:
        
        ## From Save
        
        Pass a list of `RelationalTag` instances as the `tags` arg.
        
        ## Flat
        
        Pass a list of tag name strings. Tags will not have any relationships with each other.
        Repeated tag names are allowed.
        
        Example:
        
        ```
        [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
        ```
        
        ## Hierarchy
        
        Pass a dict, where each key is a tag name string, and each value is either a single
        tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
        
        Example:
        
        ```
        {
            &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
            &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
            &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
            &#39;sport&#39;: &#39;football&#39;
        }
        ```
        
        ## Args
        
        **tags** Relational tags, either as a list or dict. Entities not supported.
        
        **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
        of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
        `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if isinstance(tags, List):
            for tag in tags:
                if isinstance(tag,RelationalTag):
                    if tag in all_tags:
                        log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                    
                    all_tags[tag.name] = tag
                
                elif isinstance(tag,str):
                    cls.new(tag, get_if_exists=True)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported tag type {}&#39;.format(type(tag)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag in tags
            
        elif isinstance(tags, Dict):
            for tag, value in tags.items():
                # create new parent tag
                rtag = cls.new(tag, get_if_exists=True)
                
                if isinstance(value,List):
                    # tag to many
                    for val in value:
                        ttag = cls.get(val, new_if_missing=True)
                        cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
                
                elif isinstance(value,str):
                    # tag to one
                    ttag = cls.get(value, new_if_missing=True)
                    cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported target type {}&#39;.format(type(value)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag,value in tags
            
        else:
            raise RelationalTagError(
                &#39;unsupported tags type {}&#39;.format(type(tags)),
                type=RelationalTagError.TYPE_WRONG_TYPE
            )
        
        return list(cls.all_tags.values())
    # end load
    
    @classmethod
    def _entity_to_hashable(cls,entity:Union[RelationalEntity,Any]) -&gt; Union[HashableEntity,RelationalEntity,Any]:
        &#34;&#34;&#34;Wraps the entity in a `HashableEntity` instance if not hashable already.
        
        A `RelationalEntity` subclass instance will be hashable, so it will be left alone.
        &#34;&#34;&#34;
        
        if &#39;__hash__&#39; in dir(entity) and entity.__hash__ is not None:
            return entity
        
        else:
            return HashableEntity(entity)
    # end _entity_to_hashable
    
    @classmethod
    def _hashable_to_entity(cls,entity:Union[HashableEntity,Any]) -&gt; Any:
        if isinstance(entity,HashableEntity):
            return entity.entity
        
        else:
            return entity
    # end _hashable_to_entity
    
    @classmethod
    def connect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None, connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Connect a tag with a target.
        &#34;&#34;&#34;
        
        if isinstance(tag_or_connection, RelationalTagConnection):
            connection:RelationalTagConnection = tag_or_connection
            cls.connect(connection.source, connection.target, connection.type)
        
        else:
            tag:RelationalTag = tag_or_connection
            
            # resolve connection type
            if connection_type is None:
                if isinstance(target,RelationalTag):
                    connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
                else:
                    connection_type = RelationalTagConnection.TO_ENT
        
            # connection
            connection = RelationalTagConnection(
                source=tag,
                target=target,
                connection_type=connection_type
            )
            tag.connections[cls._entity_to_hashable(target)] = connection
            
            # inverse connection
            inverse_connection = connection.inverse()
            if isinstance(target,RelationalTag):
                # tag connection
                target.connections[tag] = inverse_connection
            else:
                # entity connection
                entity = cls._entity_to_hashable(target)
                
                if not entity in cls._tagged_entities:
                    cls._tagged_entities[entity] = {}
                
                cls._tagged_entities[entity][tag] = inverse_connection
        
            # return
            return connection
    # end connect
    
    @classmethod
    def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
        &#34;&#34;&#34;Disconnect a tag from a target.
        
        ## Args
        
        **tag_or_connection** Either a relational tag source, or the connection that contains info
        about both the source and the target.
        
        **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
        &#34;&#34;&#34;
        
        if isinstance(tag_or_connection, RelationalTagConnection):
            # disconnect connection
            cls.disconnect(tag_or_connection.source, tag_or_connection.target)
        
        else:
            hashable_target = cls._entity_to_hashable(target)
            
            # disconnect tag-target
            del tag.connections[hashable_target]
            
            # TODO here, then finish RelationalTag.load
            if isinstance(target,RelationalTag):
                # tag connection
                # disconnect target-tag
                del target.connections[tag]
            
            else:
                # entity connection
                # disconnect target-tag
                if hashable_target in _tagged_entities:
                    del _tagged_entities[hashable_target][tag]
                    
                else:
                    log.warning(&#39;entity {} already untagged&#39;.format(target))
    # end connect
    
    @classmethod
    def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
        tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
        
        for relational_entity,connections in cls._tagged_entities.items():
            raw_entity = cls._hashable_to_entity(relational_entity)
            tagged_entities.append((raw_entity, connections))
        
        return tagged_entities
    # end get_tagged_entities
    
    @classmethod
    def load_json(cls, json_in:str) -&gt; List[&#39;RelationalTag&#39;]:
        &#34;&#34;&#34;Load all tags and connections from a json string created by `RelationalTag.save_json`.
        &#34;&#34;&#34;
        
        tag_dicts:List[Dict] = json.loads(json_in)
        
        cls.load(tags=[
            cls.load_tag(tag_dict)
            for tag_dict in tag_dicts
        ])
        
        return list(cls.all_tags.values())
    # end load_json
    
    @classmethod
    def save_json(cls) -&gt; str:
        &#34;&#34;&#34;Save all tags and connections as a json string.
        
        Entities not included.
        &#34;&#34;&#34;
        
        return &#39;[{}]&#39;.format(
            &#39;,&#39;.join([
                str(tag) for tag in cls.all_tags.values()
            ])
        )
    # end save_json
    
    @classmethod
    def load_tag(cls, tag_str:Union[str,Dict], get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
        &#34;&#34;&#34;Load a tag from its json string representation, or equivalent dict.
        &#34;&#34;&#34;
        
        # { name: [ [src,type,target] ... ] }
        if isinstance(tag_str,Dict):
            tag_json = tag_str
        else:
            tag_json:Dict[str,List[List[str]]] = json.loads(tag_str)
        
        tag = cls.new(list(tag_json.keys())[0], get_if_exists)
        
        conn_arrs = tag_json[tag.name]
        for conn_arr in conn_arrs:
            connection_type = RelationalTagConnection.str_to_type(conn_arr[1])
            if connection_type in RelationalTagConnection._TAG_TAG_TYPES:
                target_tag = cls.get(conn_arr[2])
                
                cls.connect(
                    tag_or_connection=tag, 
                    connection_type=connection_type,
                    target=target_tag
                )
            
            else:
                try:
                    target_entity_json:Dict = conn_arr[2]
                    target_entity_cls:Type = RelationalEntity.classes[
                        target_entity_json[RelationalEntity._ATTR_CLASS]
                    ]
                    
                    target_entity:RelationalEntity = target_entity_cls.load_entity(
                        entity_json=target_entity_json
                    )
                    
                    cls.connect(
                        tag_or_connection=tag,
                        connection_type=connection_type,
                        target=target_entity
                    )
                    
                except (KeyError, json.decoder.JSONDecodeError) as e:
                    cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}-{}&#39;.format(
                        conn_arr[2],
                        conn_arr[0], 
                        connection_type,
                        conn_arr[2]
                    ))
        # end for conn_str in conns
        
        return tag
    # end from_string
    
    @classmethod
    def save_tag(cls, tag:Union[str,&#39;RelationalTag&#39;]) -&gt; str:
        &#34;&#34;&#34;Export the given tag or tag of given name as a string.&#34;&#34;&#34;
        
        # convert to RelationalTag
        if isinstance(tag,str):
            tag = cls.get(name=tag, new_if_missing=False)
        
        # export
        return str(tag)
    # end save_tag
    
    def __init__(self, name:str):
        &#34;&#34;&#34;RelationalTag constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if not cls._is_case_sensitive:
            name = name.lower()
        
        if name in cls.all_tags:
            raise RelationalTagError(&#39;tag {} already exists&#39;.format(name))
        
        else:
            self.name = name
            &#34;&#34;&#34;Tag name.
            &#34;&#34;&#34;
            
            self.connections:Dict[Union[RelationalTag,Any], RelationalTagConnection] = {}
            &#34;&#34;&#34;Tag connections (relationships).
            
            Connection keys are equal to `RelationalTagConnection.target`.
            &#34;&#34;&#34;
            
            cls.all_tags[self.name] = self
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTag string representation.
        &#34;&#34;&#34;
        
        return &#39;{{&#34;{}&#34;:[{}]}}&#39;.format(
            self.name,
            &#39;,&#39;.join([str(conn) for conn in self.connections.values()])
        )
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTag) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash(self.name)
    # end __hash__
    
    def connect_to(self, other:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None):
        &#34;&#34;&#34;Connect tag to another tag or entity.
        
        Calls the class method `RelationalTag.connect`.
        &#34;&#34;&#34;
        
        type(self).connect(
            tag_or_connection=self,
            target=other,
            connection_type=connection_type
        )
    # end connect_to
    
    def disconnect_to(self, other:Union[&#39;RelationalTag&#39;,Any]):
        &#34;&#34;&#34;Disconnect tag from another tag or entity.
        
        Calls the class method `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        type(self).disconnect(tag=self,target=other)
    # end disconnect_to
    
    def delete_self(self):
        type(self).delete(self)
    # end delete
# end RelationalTag

class RelationalTagConnection:
    &#34;&#34;&#34;Relational tag connection.
    &#34;&#34;&#34;
    
    log:logging.Logger = logging.getLogger(&#39;{}.RelationalTagConnection&#39;.format(__name__))
    
    TO_TAG_UNDIRECTED:int = 1
    &#34;&#34;&#34;Undirected tag-tag connection.&#34;&#34;&#34;
    TO_TAG_PARENT:int = 2
    &#34;&#34;&#34;Child-parent tag-tag connection.&#34;&#34;&#34;
    TO_TAG_CHILD:int = 3
    &#34;&#34;&#34;Parent-child tag-tag connection.&#34;&#34;&#34;
    TO_ENT:int = 4
    &#34;&#34;&#34;Tag-entity connection.&#34;&#34;&#34;
    ENT_TO_TAG:int = 5
    &#34;&#34;&#34;Entity-tag connection.&#34;&#34;&#34;
    
    _TAG_TAG_TYPES:List[int] = [TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD]
    &#34;&#34;&#34;All tag-tag connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    &#34;&#34;&#34;
    
    _TAG_ENT_TYPES:List[int] = [TO_ENT,ENT_TO_TAG]
    &#34;&#34;&#34;All tag-entity connection types.
    
    ## Items
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    _TYPES:List[int] = [
        TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD,TO_ENT,ENT_TO_TAG
    ]
    &#34;&#34;&#34;All connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    @classmethod
    def type_to_str(cls,type:int) -&gt; str:
        &#34;&#34;&#34;Convert connection type code to string.
        &#34;&#34;&#34;
        
        if type == cls.TO_TAG_UNDIRECTED:
            return &#39;to-tag-undirected&#39;
        
        elif type == cls.TO_TAG_PARENT:
            return &#39;to-tag-parent&#39;
        
        elif type == cls.TO_TAG_CHILD:
            return &#39;to-tag-child&#39;
            
        elif type == cls.TO_ENT:
            return &#39;to-entity&#39;
            
        elif type == cls.ENT_TO_TAG:
            return &#39;entity-to-tag&#39;
    # end type_to_str
    
    @classmethod
    def str_to_type(cls,string:str) -&gt; int:
        &#34;&#34;&#34;Convert connection type string to code.
        &#34;&#34;&#34;
        
        if string == &#39;to-tag-undirected&#39;:
            return cls.TO_TAG_UNDIRECTED
        
        elif string == &#39;to-tag-parent&#39;:
            return cls.TO_TAG_PARENT
        
        elif string == &#39;to-tag-child&#39;:
            return cls.TO_TAG_CHILD
            
        elif string == &#39;to-entity&#39;:
            return cls.TO_ENT
            
        elif string == &#39;entity-to-tag&#39;:
            return cls.ENT_TO_TAG
    # end str_to_type
    
    @classmethod
    def inverse_type(cls,type:int) -&gt; int:
        if type == cls.TO_TAG_PARENT:
            return cls.TO_TAG_CHILD
        
        elif type == cls.TO_TAG_CHILD:
            return cls.TO_TAG_PARENT
        
        elif type == cls.TO_ENT:
            return cls.ENT_TO_TAG
            
        elif type == cls.ENT_TO_TAG:
            return cls.TO_ENT
            
        else:
            return type
    # end reverse_type
    
    @classmethod
    def load_connection(cls, connection_str:str) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Load connection from string representation.
        &#34;&#34;&#34;
        
        connection_arr:List[str] = json.loads(connection_str)
        
        if len(connection_arr) == 3:
            source_str = connection_arr[0]
            connection_type = cls.str_to_type(connection_arr[1])
            target_str = connection_arr[2]
            invert:bool = False
            
            # load source
            if isinstance(source_str,str):
                source:RelationalTag = RelationalTag.get(source_str)
                invert = False
                
            else:
                invert = True
                
                try:
                    source_json:Dict = source_str
                    source_cls:Type = RelationalEntity.classes[
                        source_json[RelationalEntity._ATTR_CLASS]
                    ]
                    source:RelationalEntity = source_cls(source_json)
                
                except:
                    cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}&#39;.format(
                        source_str,
                        source_str, 
                        target_str
                    ))
                    return None
            # end else not str
            
            # load target
            if isinstance(target_str,str):
                target:RelationalTag = RelationalTag.get(target_str)
                
            else:
                try:
                    target_json:Dict = source_str
                    target_cls:Type = RelationalEntity.classes[
                        target_json[RelationalEntity._ATTR_CLASS]
                    ]
                    target:RelationalEntity = target_cls(target_json)
                
                except:
                    cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}&#39;.format(
                        target_str,
                        source_str, 
                        target_str
                    ))
                    return None
            # end else not str
            
            if invert:
                temp = source
                source = target
                target = temp
                del temp
            
            # load connection
            RelationalTag.connect(
                tag_or_connection=source,
                target=target,
                connection_type=connection_type
            )
            
        else:
            raise RelationalTagError(
                &#39;invalid connection string {}&#39;.format(connection_str),
                RelationalTagError.TYPE_FORMAT
            )
    # end load_connection
    
    def __init__(self, source:RelationalTag, target:Union[RelationalTag,Any], connection_type=TO_ENT):
        &#34;&#34;&#34;RelationalTagConnection constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        self.source:RelationalTag = source
        &#34;&#34;&#34;Connection source; must be a `RelationalTag`.
        &#34;&#34;&#34;
        
        self.target:Union[RelationalTag,Any] = target
        &#34;&#34;&#34;Connection target; either a `RelationalTag`, or an entity.
        &#34;&#34;&#34;
        
        self.type = connection_type
        &#34;&#34;&#34;Connection type. See `_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if self.type in cls._TAG_TAG_TYPES and not isinstance(target,RelationalTag):
            raise RelationalTagError(
                &#39;cannot create {} connection with non-tag {}&#39;.format(
                    cls.type_to_str(self.type),
                    target
                ),
                RelationalTagError.TYPE_WRONG_TYPE
            )
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTagConnection string representation.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if isinstance(self.source,RelationalTag):
            # don&#39;t use __str__, as it would case recursion
            source_str = &#39;&#34;{}&#34;&#39;.format(self.source.name)
        else:
            source_str = str(self.source)
        
        if isinstance(self.target,RelationalTag):
            # don&#39;t use __str__, as it would case recursion
            target_str = &#39;&#34;{}&#34;&#39;.format(self.target.name)
        else:
            target_str = str(self.target)
        
        return &#39;[{},&#34;{}&#34;,{}]&#39;.format(source_str,cls.type_to_str(self.type),target_str)
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTagConnection) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash((self.source, self.target, self.type))
    # end __hash__
    
    def inverse(self) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Return inverse connection.
        &#34;&#34;&#34;
        
        return RelationalTagConnection(
            source=self.target,
            target=self.source,
            connection_type=type(self).inverse_type(self.type)
        )
    # end inverse
    
    def disconnect(self):
        &#34;&#34;&#34;Disconnect source and target.
        
        Convenience method for `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        RelationalTag.disconnect(tag_or_connection=self)
    # end disconnect
# end RelationalTagConnection

class RelationalTagError(Exception):
    &#34;&#34;&#34;Relational tag error.
    &#34;&#34;&#34;
    
    TYPE_COLLISION = 1
    TYPE_MISSING = 2
    TYPE_WRONG_TYPE = 3
    TYPE_HASH_FAIL = 4
    TYPE_FORMAT = 5
    
    def __init__(self, message, type=TYPE_COLLISION):
        &#34;&#34;&#34;RelationalTagError constructor.
        &#34;&#34;&#34;
        
        super().__init__(message)
        
        self.type = type
    # end __init__
# end RelationalTagError

# alias vars

all_tags = RelationalTag.all_tags
&#34;&#34;&#34;Alias for `RelationalTag.all_tags`.
&#34;&#34;&#34;

# alias methods

config = RelationalTag.config
&#34;&#34;&#34;Alias for `RelationalTag.config`&#34;&#34;&#34;

new = RelationalTag.new
&#34;&#34;&#34;Alias for `RelationalTag.new`&#34;&#34;&#34;

get = RelationalTag.get
&#34;&#34;&#34;Alias for `RelationalTag.get`&#34;&#34;&#34;

get_tagged_entities = RelationalTag.get_tagged_entities
&#34;&#34;&#34;Alias for `RelationalTag.get_tagged_entities`&#34;&#34;&#34;

delete = RelationalTag.delete
&#34;&#34;&#34;Alias for `RelationalTag.delete`&#34;&#34;&#34;

clear = RelationalTag.clear
&#34;&#34;&#34;Alias for `RelationalTag.clear`&#34;&#34;&#34;

load = RelationalTag.load
&#34;&#34;&#34;Alias for `RelationalTag.load`&#34;&#34;&#34;

connect = RelationalTag.connect
&#34;&#34;&#34;Alias for `RelationalTag.connect`&#34;&#34;&#34;

disconnect = RelationalTag.disconnect
&#34;&#34;&#34;Alias for `RelationalTag.disconnect`&#34;&#34;&#34;

load_json = RelationalTag.load_json
&#34;&#34;&#34;Alias for `RelationalTag.load_json`&#34;&#34;&#34;

save_json = RelationalTag.save_json
&#34;&#34;&#34;Alias for `RelationalTag.save_json`&#34;&#34;&#34;

load_tag = RelationalTag.load_tag
&#34;&#34;&#34;Alias for `RelationalTag.load_tag`&#34;&#34;&#34;

save_tag = RelationalTag.save_tag
&#34;&#34;&#34;Alias for `RelationalTag.save_tag`&#34;&#34;&#34;

# exports

__all__ = [
    &#39;VERSION&#39;,
    
    &#39;RelationalTag&#39;,
    &#39;RelationalTagConnection&#39;,
    &#39;RelationalTagError&#39;,
    &#39;RelationalEntity&#39;,
    
    &#39;all_tags&#39;,
    
    &#39;config&#39;,
    &#39;new&#39;,
    &#39;get&#39;,
    &#39;get_tagged_entities&#39;,
    &#39;delete&#39;,
    &#39;clear&#39;,
    &#39;load&#39;,
    &#39;connect&#39;,
    &#39;disconnect&#39;,
    &#39;load_json&#39;,
    &#39;save_json&#39;,
    &#39;load_tag&#39;,
    &#39;save_tag&#39;
]</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="relational_tags.VERSION"><code class="name">var <span class="ident">VERSION</span> : str</code></dt>
<dd>
<div class="desc"><p>Package version.</p></div>
</dd>
<dt id="relational_tags.all_tags"><code class="name">var <span class="ident">all_tags</span></code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="relational_tags.RelationalTag.all_tags" href="#relational_tags.RelationalTag.all_tags">RelationalTag.all_tags</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="relational_tags.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clear(cls) -&gt; int:
    num_tags = len(cls.all_tags)
    
    cls.all_tags = {}
    cls._tagged_entities = {}
    
    return num_tags</code></pre>
</details>
</dd>
<dt id="relational_tags.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>is_case_sensitive: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial configuration.</p>
<h2 id="configured-variables">Configured variables</h2>
<p><code>RelationalTag._is_case_sensitive</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def config(cls, is_case_sensitive:bool=False):
    &#34;&#34;&#34;Initial configuration.
    
    ## Configured variables
    
    `RelationalTag._is_case_sensitive`
    &#34;&#34;&#34;
    
    cls._is_case_sensitive = is_case_sensitive</code></pre>
</details>
</dd>
<dt id="relational_tags.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>tag_or_connection: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), ForwardRef('<a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>')], target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any] = None, connection_type: int = None) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a tag with a target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def connect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None, connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Connect a tag with a target.
    &#34;&#34;&#34;
    
    if isinstance(tag_or_connection, RelationalTagConnection):
        connection:RelationalTagConnection = tag_or_connection
        cls.connect(connection.source, connection.target, connection.type)
    
    else:
        tag:RelationalTag = tag_or_connection
        
        # resolve connection type
        if connection_type is None:
            if isinstance(target,RelationalTag):
                connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
            else:
                connection_type = RelationalTagConnection.TO_ENT
    
        # connection
        connection = RelationalTagConnection(
            source=tag,
            target=target,
            connection_type=connection_type
        )
        tag.connections[cls._entity_to_hashable(target)] = connection
        
        # inverse connection
        inverse_connection = connection.inverse()
        if isinstance(target,RelationalTag):
            # tag connection
            target.connections[tag] = inverse_connection
        else:
            # entity connection
            entity = cls._entity_to_hashable(target)
            
            if not entity in cls._tagged_entities:
                cls._tagged_entities[entity] = {}
            
            cls._tagged_entities[entity][tag] = inverse_connection
    
        # return
        return connection</code></pre>
</details>
</dd>
<dt id="relational_tags.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>tag: Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
    try:
        # convert tag to RelationalTag
        if isinstance(tag,str):
            if not cls._is_case_sensitive:
                tag = tag.lower()
            
            tag = cls.all_tags[tag]
        # end if not RelationalTag
        
        cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
        
        # delete references from others
        for connection in tag.connections.values():
            other = connection.target
            
            if isinstance(other, RelationalTag):
                # disconnect from other tag
                del other.connections[tag]
            
            else:
                # disconnect from entity
                del cls._tagged_entities[cls._entity_to_hashable(other)][tag]
        # end for connection in connections
        
        # delete tag
        del cls.all_tags[tag.name]
    
    except KeyError as e:
        cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))</code></pre>
</details>
</dd>
<dt id="relational_tags.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>tag_or_connection: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), ForwardRef('<a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>')], target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect a tag from a target.</p>
<h2 id="args">Args</h2>
<p><strong>tag_or_connection</strong> Either a relational tag source, or the connection that contains info
about both the source and the target.</p>
<p><strong>target</strong> Connection target, or <code>None</code> if a connection was provided for <code>tag_or_connection</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
    &#34;&#34;&#34;Disconnect a tag from a target.
    
    ## Args
    
    **tag_or_connection** Either a relational tag source, or the connection that contains info
    about both the source and the target.
    
    **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
    &#34;&#34;&#34;
    
    if isinstance(tag_or_connection, RelationalTagConnection):
        # disconnect connection
        cls.disconnect(tag_or_connection.source, tag_or_connection.target)
    
    else:
        hashable_target = cls._entity_to_hashable(target)
        
        # disconnect tag-target
        del tag.connections[hashable_target]
        
        # TODO here, then finish RelationalTag.load
        if isinstance(target,RelationalTag):
            # tag connection
            # disconnect target-tag
            del target.connections[tag]
        
        else:
            # entity connection
            # disconnect target-tag
            if hashable_target in _tagged_entities:
                del _tagged_entities[hashable_target][tag]
                
            else:
                log.warning(&#39;entity {} already untagged&#39;.format(target))</code></pre>
</details>
</dd>
<dt id="relational_tags.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name: str, new_if_missing: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = cls.all_tags[name]
        return rtag
        
    except KeyError as e:
        cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
        
        if new_if_missing:
            rtag = RelationalTag(name=name)
            return rtag
        else:
            raise RelationalTagError(
                &#39;tag {} missing&#39;.format(name), 
                RelationalTagError.TYPE_MISSING
            )
    # end except</code></pre>
</details>
</dd>
<dt id="relational_tags.get_tagged_entities"><code class="name flex">
<span>def <span class="ident">get_tagged_entities</span></span>(<span>) ‑> List[Tuple[Any, Dict[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
    tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
    
    for relational_entity,connections in cls._tagged_entities.items():
        raw_entity = cls._hashable_to_entity(relational_entity)
        tagged_entities.append((raw_entity, connections))
    
    return tagged_entities</code></pre>
</details>
</dd>
<dt id="relational_tags.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>tags: Union[List[Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')]], Dict[str, Union[str, List[str]]]], tag_tag_type: int = 'RelationalTagConnection.TO_TAG_CHILD') ‑> List[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a set of tags, including optional connection info for each.</p>
<p>There are multiple ways to define a relational tags system:</p>
<h2 id="from-save">From Save</h2>
<p>Pass a list of <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code> instances as the <code>tags</code> arg.</p>
<h2 id="flat">Flat</h2>
<p>Pass a list of tag name strings. Tags will not have any relationships with each other.
Repeated tag names are allowed.</p>
<p>Example:</p>
<pre><code>['apple','banana','cinnamon','donut']
</code></pre>
<h2 id="hierarchy">Hierarchy</h2>
<p>Pass a dict, where each key is a tag name string, and each value is either a single
tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.</p>
<p>Example:</p>
<pre><code>{
    'fruit': ['apple','banana','orange'],
    'food': ['fruit','vegetable'],
    'color': ['red','blue','green','orange'],
    'sport': 'football'
}
</code></pre>
<h2 id="args">Args</h2>
<p><strong>tags</strong> Relational tags, either as a list or dict. Entities not supported.</p>
<p><strong>tag_tag_type</strong> Specify what a key-value relationship in a dictionary means. Default
of <code><a title="relational_tags.RelationalTagConnection.TO_TAG_CHILD" href="#relational_tags.RelationalTagConnection.TO_TAG_CHILD">RelationalTagConnection.TO_TAG_CHILD</a></code> means the key is the parent of the value. See
<code>RelationalTagConnection._TAG_TAG_TYPES</code> for possible values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
    &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
    
    There are multiple ways to define a relational tags system:
    
    ## From Save
    
    Pass a list of `RelationalTag` instances as the `tags` arg.
    
    ## Flat
    
    Pass a list of tag name strings. Tags will not have any relationships with each other.
    Repeated tag names are allowed.
    
    Example:
    
    ```
    [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
    ```
    
    ## Hierarchy
    
    Pass a dict, where each key is a tag name string, and each value is either a single
    tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
    
    Example:
    
    ```
    {
        &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
        &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
        &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
        &#39;sport&#39;: &#39;football&#39;
    }
    ```
    
    ## Args
    
    **tags** Relational tags, either as a list or dict. Entities not supported.
    
    **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
    of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
    `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
    &#34;&#34;&#34;
    
    if isinstance(tags, List):
        for tag in tags:
            if isinstance(tag,RelationalTag):
                if tag in all_tags:
                    log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                
                all_tags[tag.name] = tag
            
            elif isinstance(tag,str):
                cls.new(tag, get_if_exists=True)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported tag type {}&#39;.format(type(tag)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag in tags
        
    elif isinstance(tags, Dict):
        for tag, value in tags.items():
            # create new parent tag
            rtag = cls.new(tag, get_if_exists=True)
            
            if isinstance(value,List):
                # tag to many
                for val in value:
                    ttag = cls.get(val, new_if_missing=True)
                    cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
            
            elif isinstance(value,str):
                # tag to one
                ttag = cls.get(value, new_if_missing=True)
                cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported target type {}&#39;.format(type(value)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag,value in tags
        
    else:
        raise RelationalTagError(
            &#39;unsupported tags type {}&#39;.format(type(tags)),
            type=RelationalTagError.TYPE_WRONG_TYPE
        )
    
    return list(cls.all_tags.values())</code></pre>
</details>
</dd>
<dt id="relational_tags.load_json"><code class="name flex">
<span>def <span class="ident">load_json</span></span>(<span>json_in: str) ‑> List[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load all tags and connections from a json string created by <code><a title="relational_tags.RelationalTag.save_json" href="#relational_tags.RelationalTag.save_json">RelationalTag.save_json()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_json(cls, json_in:str) -&gt; List[&#39;RelationalTag&#39;]:
    &#34;&#34;&#34;Load all tags and connections from a json string created by `RelationalTag.save_json`.
    &#34;&#34;&#34;
    
    tag_dicts:List[Dict] = json.loads(json_in)
    
    cls.load(tags=[
        cls.load_tag(tag_dict)
        for tag_dict in tag_dicts
    ])
    
    return list(cls.all_tags.values())</code></pre>
</details>
</dd>
<dt id="relational_tags.load_tag"><code class="name flex">
<span>def <span class="ident">load_tag</span></span>(<span>tag_str: Union[str, Dict], get_if_exists: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a tag from its json string representation, or equivalent dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_tag(cls, tag_str:Union[str,Dict], get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
    &#34;&#34;&#34;Load a tag from its json string representation, or equivalent dict.
    &#34;&#34;&#34;
    
    # { name: [ [src,type,target] ... ] }
    if isinstance(tag_str,Dict):
        tag_json = tag_str
    else:
        tag_json:Dict[str,List[List[str]]] = json.loads(tag_str)
    
    tag = cls.new(list(tag_json.keys())[0], get_if_exists)
    
    conn_arrs = tag_json[tag.name]
    for conn_arr in conn_arrs:
        connection_type = RelationalTagConnection.str_to_type(conn_arr[1])
        if connection_type in RelationalTagConnection._TAG_TAG_TYPES:
            target_tag = cls.get(conn_arr[2])
            
            cls.connect(
                tag_or_connection=tag, 
                connection_type=connection_type,
                target=target_tag
            )
        
        else:
            try:
                target_entity_json:Dict = conn_arr[2]
                target_entity_cls:Type = RelationalEntity.classes[
                    target_entity_json[RelationalEntity._ATTR_CLASS]
                ]
                
                target_entity:RelationalEntity = target_entity_cls.load_entity(
                    entity_json=target_entity_json
                )
                
                cls.connect(
                    tag_or_connection=tag,
                    connection_type=connection_type,
                    target=target_entity
                )
                
            except (KeyError, json.decoder.JSONDecodeError) as e:
                cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}-{}&#39;.format(
                    conn_arr[2],
                    conn_arr[0], 
                    connection_type,
                    conn_arr[2]
                ))
    # end for conn_str in conns
    
    return tag</code></pre>
</details>
</dd>
<dt id="relational_tags.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>name: str, get_if_exists: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = RelationalTag(name=name)
        return rtag
    
    except RelationalTagError as e:
        cls.log.warning(str(e))
        
        if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
            return cls.all_tags[name]
        else:
            raise e
    # end except</code></pre>
</details>
</dd>
<dt id="relational_tags.save_json"><code class="name flex">
<span>def <span class="ident">save_json</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Save all tags and connections as a json string.</p>
<p>Entities not included.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_json(cls) -&gt; str:
    &#34;&#34;&#34;Save all tags and connections as a json string.
    
    Entities not included.
    &#34;&#34;&#34;
    
    return &#39;[{}]&#39;.format(
        &#39;,&#39;.join([
            str(tag) for tag in cls.all_tags.values()
        ])
    )</code></pre>
</details>
</dd>
<dt id="relational_tags.save_tag"><code class="name flex">
<span>def <span class="ident">save_tag</span></span>(<span>tag: Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Export the given tag or tag of given name as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_tag(cls, tag:Union[str,&#39;RelationalTag&#39;]) -&gt; str:
    &#34;&#34;&#34;Export the given tag or tag of given name as a string.&#34;&#34;&#34;
    
    # convert to RelationalTag
    if isinstance(tag,str):
        tag = cls.get(name=tag, new_if_missing=False)
    
    # export
    return str(tag)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="relational_tags.RelationalEntity"><code class="flex name class">
<span>class <span class="ident">RelationalEntity</span></span>
</code></dt>
<dd>
<div class="desc"><p>Relational entity abstract class.</p>
<p>Subclass this abstract class and implement the required methods in order to
define an entity that is fully compatible with relational tagging.</p>
<p>Note it is not necessary to use RelationalEntity subclasses in order to
use relational tagging; anything can be an entity and can be tagged. However,
subclasses if <code><a title="relational_tags.RelationalEntity" href="#relational_tags.RelationalEntity">RelationalEntity</a></code> are required in order to include them in the
built-in persistence methods provided: <code><a title="relational_tags.save_json" href="#relational_tags.save_json">RelationalTag.save_json()</a></code>, <code><a title="relational_tags.load_json" href="#relational_tags.load_json">RelationalTag.load_json()</a></code>.</p>
<h2 id="relationalentity-constructor">RelationalEntity constructor.</h2>
<p>A subclass with its own constructor should call this superconstructor with:</p>
<pre><code>super().__init__()
</code></pre>
<p>or implement equivalent code in its own constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalEntity:
    &#34;&#34;&#34;Relational entity abstract class.
    
    Subclass this abstract class and implement the required methods in order to 
    define an entity that is fully compatible with relational tagging.
    
    Note it is not necessary to use RelationalEntity subclasses in order to 
    use relational tagging; anything can be an entity and can be tagged. However, 
    subclasses if `RelationalEntity` are required in order to include them in the
    built-in persistence methods provided: `save_json`, `load_json`.
    &#34;&#34;&#34;
    
    _ATTR_CLASS:str = &#39;class&#39;
    
    classes:Dict[str,Type[&#39;RelationalEntity&#39;]] = {}
    &#34;&#34;&#34;Maintains a name-class dictionary for identifying serialized subclass instances.
    
    Sublasses of `RelationalEntity` are automatically added to this dictionary with
    `RelationalEntity.__init__`.
    &#34;&#34;&#34;
    
    @classmethod
    def load_entity(cls, entity_json:Union[str,Dict]) -&gt; &#39;RelationalEntity&#39;:
        &#34;&#34;&#34;A relational entity must be able to deserialize itself.
        
        Note this method will be used to deserialize an entity from its json string
        representation, or equivalent python dict.
        
        ## Args
        
        **entity_json** Either a json representation of the entity (created from 
        `RelaionalEntity.__str__`, or an equivalent python dict)
        &#34;&#34;&#34;
        
        raise NotImplementedError(
            &#39;RelationalEntity is an abstract class; subclass implements load_entity&#39;
        )
    # end load_entity
    
    def __init__(self):
        &#34;&#34;&#34;## RelationalEntity constructor.
        
        A subclass with its own constructor should call this superconstructor with:
        
        ```
        super().__init__()
        ```
        
        or implement equivalent code in its own constructor.
        &#34;&#34;&#34;
        
        cls_name = RelationalEntity.__name__
        if cls_name not in RelationalEntity.classes:
            RelationalEntity.classes[cls_name] = RelationalEntity
        
        subcls = type(self)
        RelationalEntity.classes[subcls.__name__] = subcls
    # end __init__
    
    def __hash__(self):
        &#34;&#34;&#34;A relational entity must be hashable.
        
        This method will be used to check equivalence between different entities and
        to use them as dictionary keys for quick access.
        &#34;&#34;&#34;
        
        raise NotImplementedError(
            &#39;RelationalEntity is an abstract class; subclass implements __hash__&#39;
        )
    # end __hash__
    
    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Default implementation of equality.
        
        You should not need to override this method unless you want more strict equality
        checking.
        &#34;&#34;&#34;
        
        return hash(self) == hash(other)
    # end __eq__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;A relational entity must be able to serialize itself.
        
        Note this method will be used to serialize this instance so that it can be included
        in a relational tags json save file.
        
        ## Requirements
        
        Compatible with overridden `RelationalEntity.load_entity`.
        
        The resultant string is valid json.
        
        The json string represents a dictionary with the following initial structure:
        
        ```
        {
            &#34;class&#34;: &#34;&lt;class-name&gt;&#34;  # &lt;class-name&gt; = type(self).__name__
        }
        ```
        &#34;&#34;&#34;
        
        raise NotImplementedError(
            &#39;RelationalEntity is an abstract class; subclass implements __str__&#39;
        )
    # end __str__</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalEntity.classes"><code class="name">var <span class="ident">classes</span> : Dict[str, Type[<a title="relational_tags.RelationalEntity" href="#relational_tags.RelationalEntity">RelationalEntity</a>]]</code></dt>
<dd>
<div class="desc"><p>Maintains a name-class dictionary for identifying serialized subclass instances.</p>
<p>Sublasses of <code><a title="relational_tags.RelationalEntity" href="#relational_tags.RelationalEntity">RelationalEntity</a></code> are automatically added to this dictionary with
<code><a title="relational_tags.RelationalEntity" href="#relational_tags.RelationalEntity">RelationalEntity</a></code>.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="relational_tags.RelationalEntity.load_entity"><code class="name flex">
<span>def <span class="ident">load_entity</span></span>(<span>entity_json: Union[str, Dict]) ‑> <a title="relational_tags.RelationalEntity" href="#relational_tags.RelationalEntity">RelationalEntity</a></span>
</code></dt>
<dd>
<div class="desc"><p>A relational entity must be able to deserialize itself.</p>
<p>Note this method will be used to deserialize an entity from its json string
representation, or equivalent python dict.</p>
<h2 id="args">Args</h2>
<p><strong>entity_json</strong> Either a json representation of the entity (created from
<code>RelaionalEntity.__str__</code>, or an equivalent python dict)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_entity(cls, entity_json:Union[str,Dict]) -&gt; &#39;RelationalEntity&#39;:
    &#34;&#34;&#34;A relational entity must be able to deserialize itself.
    
    Note this method will be used to deserialize an entity from its json string
    representation, or equivalent python dict.
    
    ## Args
    
    **entity_json** Either a json representation of the entity (created from 
    `RelaionalEntity.__str__`, or an equivalent python dict)
    &#34;&#34;&#34;
    
    raise NotImplementedError(
        &#39;RelationalEntity is an abstract class; subclass implements load_entity&#39;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="relational_tags.RelationalTag"><code class="flex name class">
<span>class <span class="ident">RelationalTag</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Relational tag class.</p>
<p>A relational tag can be connected to an entity to categorize it, and also be connected to other
relational tags.</p>
<p>RelationalTag constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalTag:
    &#34;&#34;&#34;Relational tag class.
    
    A relational tag can be connected to an entity to categorize it, and also be connected to other
    relational tags.
    &#34;&#34;&#34;
    
    log:Logger = logging.getLogger(&#39;{}.RelationalTag&#39;.format(__name__))
    
    _is_case_sensitive:bool = False
    &#34;&#34;&#34;Whether tag uniqueness is case-sensitive.
    
    **default** `False`
    &#34;&#34;&#34;
    
    all_tags:Dict[str, &#39;RelationalTag&#39;] = {}
    &#34;&#34;&#34;All relational tags.&#34;&#34;&#34;
    
    _tagged_entities:Dict[Any, Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]] = {}
    &#34;&#34;&#34;All entities that have been assigned tags.
    
    Connections dict key per entity is equal to the connection&#39;s `target`.
    &#34;&#34;&#34;
    
    @classmethod
    def config(cls, is_case_sensitive:bool=False):
        &#34;&#34;&#34;Initial configuration.
        
        ## Configured variables
        
        `RelationalTag._is_case_sensitive`
        &#34;&#34;&#34;
        
        cls._is_case_sensitive = is_case_sensitive
    # end config
    
    @classmethod
    def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = RelationalTag(name=name)
            return rtag
        
        except RelationalTagError as e:
            cls.log.warning(str(e))
            
            if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
                return cls.all_tags[name]
            else:
                raise e
        # end except
    # end new
    
    @classmethod
    def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
        if not cls._is_case_sensitive:
            name = name.lower()
        
        try:
            rtag = cls.all_tags[name]
            return rtag
            
        except KeyError as e:
            cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
            
            if new_if_missing:
                rtag = RelationalTag(name=name)
                return rtag
            else:
                raise RelationalTagError(
                    &#39;tag {} missing&#39;.format(name), 
                    RelationalTagError.TYPE_MISSING
                )
        # end except
    # end get
    
    @classmethod
    def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
        try:
            # convert tag to RelationalTag
            if isinstance(tag,str):
                if not cls._is_case_sensitive:
                    tag = tag.lower()
                
                tag = cls.all_tags[tag]
            # end if not RelationalTag
            
            cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
            
            # delete references from others
            for connection in tag.connections.values():
                other = connection.target
                
                if isinstance(other, RelationalTag):
                    # disconnect from other tag
                    del other.connections[tag]
                
                else:
                    # disconnect from entity
                    del cls._tagged_entities[cls._entity_to_hashable(other)][tag]
            # end for connection in connections
            
            # delete tag
            del cls.all_tags[tag.name]
        
        except KeyError as e:
            cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))
    # end delete
    
    @classmethod
    def clear(cls) -&gt; int:
        num_tags = len(cls.all_tags)
        
        cls.all_tags = {}
        cls._tagged_entities = {}
        
        return num_tags
    # end clear
    
    @classmethod
    def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
        &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
        
        There are multiple ways to define a relational tags system:
        
        ## From Save
        
        Pass a list of `RelationalTag` instances as the `tags` arg.
        
        ## Flat
        
        Pass a list of tag name strings. Tags will not have any relationships with each other.
        Repeated tag names are allowed.
        
        Example:
        
        ```
        [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
        ```
        
        ## Hierarchy
        
        Pass a dict, where each key is a tag name string, and each value is either a single
        tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
        
        Example:
        
        ```
        {
            &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
            &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
            &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
            &#39;sport&#39;: &#39;football&#39;
        }
        ```
        
        ## Args
        
        **tags** Relational tags, either as a list or dict. Entities not supported.
        
        **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
        of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
        `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if isinstance(tags, List):
            for tag in tags:
                if isinstance(tag,RelationalTag):
                    if tag in all_tags:
                        log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                    
                    all_tags[tag.name] = tag
                
                elif isinstance(tag,str):
                    cls.new(tag, get_if_exists=True)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported tag type {}&#39;.format(type(tag)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag in tags
            
        elif isinstance(tags, Dict):
            for tag, value in tags.items():
                # create new parent tag
                rtag = cls.new(tag, get_if_exists=True)
                
                if isinstance(value,List):
                    # tag to many
                    for val in value:
                        ttag = cls.get(val, new_if_missing=True)
                        cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
                
                elif isinstance(value,str):
                    # tag to one
                    ttag = cls.get(value, new_if_missing=True)
                    cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
                
                else:
                    raise RelationalTagError(
                        &#39;unsupported target type {}&#39;.format(type(value)),
                        type=RelationalTagError.TYPE_WRONG_TYPE
                    )
            # end for tag,value in tags
            
        else:
            raise RelationalTagError(
                &#39;unsupported tags type {}&#39;.format(type(tags)),
                type=RelationalTagError.TYPE_WRONG_TYPE
            )
        
        return list(cls.all_tags.values())
    # end load
    
    @classmethod
    def _entity_to_hashable(cls,entity:Union[RelationalEntity,Any]) -&gt; Union[HashableEntity,RelationalEntity,Any]:
        &#34;&#34;&#34;Wraps the entity in a `HashableEntity` instance if not hashable already.
        
        A `RelationalEntity` subclass instance will be hashable, so it will be left alone.
        &#34;&#34;&#34;
        
        if &#39;__hash__&#39; in dir(entity) and entity.__hash__ is not None:
            return entity
        
        else:
            return HashableEntity(entity)
    # end _entity_to_hashable
    
    @classmethod
    def _hashable_to_entity(cls,entity:Union[HashableEntity,Any]) -&gt; Any:
        if isinstance(entity,HashableEntity):
            return entity.entity
        
        else:
            return entity
    # end _hashable_to_entity
    
    @classmethod
    def connect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None, connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Connect a tag with a target.
        &#34;&#34;&#34;
        
        if isinstance(tag_or_connection, RelationalTagConnection):
            connection:RelationalTagConnection = tag_or_connection
            cls.connect(connection.source, connection.target, connection.type)
        
        else:
            tag:RelationalTag = tag_or_connection
            
            # resolve connection type
            if connection_type is None:
                if isinstance(target,RelationalTag):
                    connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
                else:
                    connection_type = RelationalTagConnection.TO_ENT
        
            # connection
            connection = RelationalTagConnection(
                source=tag,
                target=target,
                connection_type=connection_type
            )
            tag.connections[cls._entity_to_hashable(target)] = connection
            
            # inverse connection
            inverse_connection = connection.inverse()
            if isinstance(target,RelationalTag):
                # tag connection
                target.connections[tag] = inverse_connection
            else:
                # entity connection
                entity = cls._entity_to_hashable(target)
                
                if not entity in cls._tagged_entities:
                    cls._tagged_entities[entity] = {}
                
                cls._tagged_entities[entity][tag] = inverse_connection
        
            # return
            return connection
    # end connect
    
    @classmethod
    def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
        &#34;&#34;&#34;Disconnect a tag from a target.
        
        ## Args
        
        **tag_or_connection** Either a relational tag source, or the connection that contains info
        about both the source and the target.
        
        **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
        &#34;&#34;&#34;
        
        if isinstance(tag_or_connection, RelationalTagConnection):
            # disconnect connection
            cls.disconnect(tag_or_connection.source, tag_or_connection.target)
        
        else:
            hashable_target = cls._entity_to_hashable(target)
            
            # disconnect tag-target
            del tag.connections[hashable_target]
            
            # TODO here, then finish RelationalTag.load
            if isinstance(target,RelationalTag):
                # tag connection
                # disconnect target-tag
                del target.connections[tag]
            
            else:
                # entity connection
                # disconnect target-tag
                if hashable_target in _tagged_entities:
                    del _tagged_entities[hashable_target][tag]
                    
                else:
                    log.warning(&#39;entity {} already untagged&#39;.format(target))
    # end connect
    
    @classmethod
    def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
        tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
        
        for relational_entity,connections in cls._tagged_entities.items():
            raw_entity = cls._hashable_to_entity(relational_entity)
            tagged_entities.append((raw_entity, connections))
        
        return tagged_entities
    # end get_tagged_entities
    
    @classmethod
    def load_json(cls, json_in:str) -&gt; List[&#39;RelationalTag&#39;]:
        &#34;&#34;&#34;Load all tags and connections from a json string created by `RelationalTag.save_json`.
        &#34;&#34;&#34;
        
        tag_dicts:List[Dict] = json.loads(json_in)
        
        cls.load(tags=[
            cls.load_tag(tag_dict)
            for tag_dict in tag_dicts
        ])
        
        return list(cls.all_tags.values())
    # end load_json
    
    @classmethod
    def save_json(cls) -&gt; str:
        &#34;&#34;&#34;Save all tags and connections as a json string.
        
        Entities not included.
        &#34;&#34;&#34;
        
        return &#39;[{}]&#39;.format(
            &#39;,&#39;.join([
                str(tag) for tag in cls.all_tags.values()
            ])
        )
    # end save_json
    
    @classmethod
    def load_tag(cls, tag_str:Union[str,Dict], get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
        &#34;&#34;&#34;Load a tag from its json string representation, or equivalent dict.
        &#34;&#34;&#34;
        
        # { name: [ [src,type,target] ... ] }
        if isinstance(tag_str,Dict):
            tag_json = tag_str
        else:
            tag_json:Dict[str,List[List[str]]] = json.loads(tag_str)
        
        tag = cls.new(list(tag_json.keys())[0], get_if_exists)
        
        conn_arrs = tag_json[tag.name]
        for conn_arr in conn_arrs:
            connection_type = RelationalTagConnection.str_to_type(conn_arr[1])
            if connection_type in RelationalTagConnection._TAG_TAG_TYPES:
                target_tag = cls.get(conn_arr[2])
                
                cls.connect(
                    tag_or_connection=tag, 
                    connection_type=connection_type,
                    target=target_tag
                )
            
            else:
                try:
                    target_entity_json:Dict = conn_arr[2]
                    target_entity_cls:Type = RelationalEntity.classes[
                        target_entity_json[RelationalEntity._ATTR_CLASS]
                    ]
                    
                    target_entity:RelationalEntity = target_entity_cls.load_entity(
                        entity_json=target_entity_json
                    )
                    
                    cls.connect(
                        tag_or_connection=tag,
                        connection_type=connection_type,
                        target=target_entity
                    )
                    
                except (KeyError, json.decoder.JSONDecodeError) as e:
                    cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}-{}&#39;.format(
                        conn_arr[2],
                        conn_arr[0], 
                        connection_type,
                        conn_arr[2]
                    ))
        # end for conn_str in conns
        
        return tag
    # end from_string
    
    @classmethod
    def save_tag(cls, tag:Union[str,&#39;RelationalTag&#39;]) -&gt; str:
        &#34;&#34;&#34;Export the given tag or tag of given name as a string.&#34;&#34;&#34;
        
        # convert to RelationalTag
        if isinstance(tag,str):
            tag = cls.get(name=tag, new_if_missing=False)
        
        # export
        return str(tag)
    # end save_tag
    
    def __init__(self, name:str):
        &#34;&#34;&#34;RelationalTag constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if not cls._is_case_sensitive:
            name = name.lower()
        
        if name in cls.all_tags:
            raise RelationalTagError(&#39;tag {} already exists&#39;.format(name))
        
        else:
            self.name = name
            &#34;&#34;&#34;Tag name.
            &#34;&#34;&#34;
            
            self.connections:Dict[Union[RelationalTag,Any], RelationalTagConnection] = {}
            &#34;&#34;&#34;Tag connections (relationships).
            
            Connection keys are equal to `RelationalTagConnection.target`.
            &#34;&#34;&#34;
            
            cls.all_tags[self.name] = self
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTag string representation.
        &#34;&#34;&#34;
        
        return &#39;{{&#34;{}&#34;:[{}]}}&#39;.format(
            self.name,
            &#39;,&#39;.join([str(conn) for conn in self.connections.values()])
        )
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTag) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash(self.name)
    # end __hash__
    
    def connect_to(self, other:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None):
        &#34;&#34;&#34;Connect tag to another tag or entity.
        
        Calls the class method `RelationalTag.connect`.
        &#34;&#34;&#34;
        
        type(self).connect(
            tag_or_connection=self,
            target=other,
            connection_type=connection_type
        )
    # end connect_to
    
    def disconnect_to(self, other:Union[&#39;RelationalTag&#39;,Any]):
        &#34;&#34;&#34;Disconnect tag from another tag or entity.
        
        Calls the class method `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        type(self).disconnect(tag=self,target=other)
    # end disconnect_to
    
    def delete_self(self):
        type(self).delete(self)
    # end delete</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalTag.all_tags"><code class="name">var <span class="ident">all_tags</span> : Dict[str, <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</code></dt>
<dd>
<div class="desc"><p>All relational tags.</p></div>
</dd>
<dt id="relational_tags.RelationalTag.log"><code class="name">var <span class="ident">log</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="relational_tags.RelationalTag.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clear(cls) -&gt; int:
    num_tags = len(cls.all_tags)
    
    cls.all_tags = {}
    cls._tagged_entities = {}
    
    return num_tags</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>is_case_sensitive: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial configuration.</p>
<h2 id="configured-variables">Configured variables</h2>
<p><code>RelationalTag._is_case_sensitive</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def config(cls, is_case_sensitive:bool=False):
    &#34;&#34;&#34;Initial configuration.
    
    ## Configured variables
    
    `RelationalTag._is_case_sensitive`
    &#34;&#34;&#34;
    
    cls._is_case_sensitive = is_case_sensitive</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>tag_or_connection: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), ForwardRef('<a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>')], target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any] = None, connection_type: int = None) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a tag with a target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def connect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None, connection_type:int=None) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Connect a tag with a target.
    &#34;&#34;&#34;
    
    if isinstance(tag_or_connection, RelationalTagConnection):
        connection:RelationalTagConnection = tag_or_connection
        cls.connect(connection.source, connection.target, connection.type)
    
    else:
        tag:RelationalTag = tag_or_connection
        
        # resolve connection type
        if connection_type is None:
            if isinstance(target,RelationalTag):
                connection_type = RelationalTagConnection.TO_TAG_UNDIRECTED
            else:
                connection_type = RelationalTagConnection.TO_ENT
    
        # connection
        connection = RelationalTagConnection(
            source=tag,
            target=target,
            connection_type=connection_type
        )
        tag.connections[cls._entity_to_hashable(target)] = connection
        
        # inverse connection
        inverse_connection = connection.inverse()
        if isinstance(target,RelationalTag):
            # tag connection
            target.connections[tag] = inverse_connection
        else:
            # entity connection
            entity = cls._entity_to_hashable(target)
            
            if not entity in cls._tagged_entities:
                cls._tagged_entities[entity] = {}
            
            cls._tagged_entities[entity][tag] = inverse_connection
    
        # return
        return connection</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>tag: Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, tag:Union[str,&#39;RelationalTag&#39;]):
    try:
        # convert tag to RelationalTag
        if isinstance(tag,str):
            if not cls._is_case_sensitive:
                tag = tag.lower()
            
            tag = cls.all_tags[tag]
        # end if not RelationalTag
        
        cls.log.debug(&#39;deleting tag {}&#39;.format(tag))
        
        # delete references from others
        for connection in tag.connections.values():
            other = connection.target
            
            if isinstance(other, RelationalTag):
                # disconnect from other tag
                del other.connections[tag]
            
            else:
                # disconnect from entity
                del cls._tagged_entities[cls._entity_to_hashable(other)][tag]
        # end for connection in connections
        
        # delete tag
        del cls.all_tags[tag.name]
    
    except KeyError as e:
        cls.log.warning(&#39;cannot delete missing tag {}&#39;.format(name))</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>tag_or_connection: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), ForwardRef('<a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>')], target: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect a tag from a target.</p>
<h2 id="args">Args</h2>
<p><strong>tag_or_connection</strong> Either a relational tag source, or the connection that contains info
about both the source and the target.</p>
<p><strong>target</strong> Connection target, or <code>None</code> if a connection was provided for <code>tag_or_connection</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def disconnect(cls, tag_or_connection:Union[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;], target:Union[&#39;RelationalTag&#39;,Any]=None):
    &#34;&#34;&#34;Disconnect a tag from a target.
    
    ## Args
    
    **tag_or_connection** Either a relational tag source, or the connection that contains info
    about both the source and the target.
    
    **target** Connection target, or `None` if a connection was provided for `tag_or_connection`.
    &#34;&#34;&#34;
    
    if isinstance(tag_or_connection, RelationalTagConnection):
        # disconnect connection
        cls.disconnect(tag_or_connection.source, tag_or_connection.target)
    
    else:
        hashable_target = cls._entity_to_hashable(target)
        
        # disconnect tag-target
        del tag.connections[hashable_target]
        
        # TODO here, then finish RelationalTag.load
        if isinstance(target,RelationalTag):
            # tag connection
            # disconnect target-tag
            del target.connections[tag]
        
        else:
            # entity connection
            # disconnect target-tag
            if hashable_target in _tagged_entities:
                del _tagged_entities[hashable_target][tag]
                
            else:
                log.warning(&#39;entity {} already untagged&#39;.format(target))</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name: str, new_if_missing: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, name:str, new_if_missing:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = cls.all_tags[name]
        return rtag
        
    except KeyError as e:
        cls.log.warning(&#39;relational tag {} not found&#39;.format(name))
        
        if new_if_missing:
            rtag = RelationalTag(name=name)
            return rtag
        else:
            raise RelationalTagError(
                &#39;tag {} missing&#39;.format(name), 
                RelationalTagError.TYPE_MISSING
            )
    # end except</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.get_tagged_entities"><code class="name flex">
<span>def <span class="ident">get_tagged_entities</span></span>(<span>) ‑> List[Tuple[Any, Dict[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a>]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_tagged_entities(cls) -&gt; List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]]:
    tagged_entities:List[Tuple[Any,Dict[&#39;RelationalTag&#39;,&#39;RelationalTagConnection&#39;]]] = []
    
    for relational_entity,connections in cls._tagged_entities.items():
        raw_entity = cls._hashable_to_entity(relational_entity)
        tagged_entities.append((raw_entity, connections))
    
    return tagged_entities</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>tags: Union[List[Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')]], Dict[str, Union[str, List[str]]]], tag_tag_type: int = 'RelationalTagConnection.TO_TAG_CHILD') ‑> List[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a set of tags, including optional connection info for each.</p>
<p>There are multiple ways to define a relational tags system:</p>
<h2 id="from-save">From Save</h2>
<p>Pass a list of <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code> instances as the <code>tags</code> arg.</p>
<h2 id="flat">Flat</h2>
<p>Pass a list of tag name strings. Tags will not have any relationships with each other.
Repeated tag names are allowed.</p>
<p>Example:</p>
<pre><code>['apple','banana','cinnamon','donut']
</code></pre>
<h2 id="hierarchy">Hierarchy</h2>
<p>Pass a dict, where each key is a tag name string, and each value is either a single
tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.</p>
<p>Example:</p>
<pre><code>{
    'fruit': ['apple','banana','orange'],
    'food': ['fruit','vegetable'],
    'color': ['red','blue','green','orange'],
    'sport': 'football'
}
</code></pre>
<h2 id="args">Args</h2>
<p><strong>tags</strong> Relational tags, either as a list or dict. Entities not supported.</p>
<p><strong>tag_tag_type</strong> Specify what a key-value relationship in a dictionary means. Default
of <code><a title="relational_tags.RelationalTagConnection.TO_TAG_CHILD" href="#relational_tags.RelationalTagConnection.TO_TAG_CHILD">RelationalTagConnection.TO_TAG_CHILD</a></code> means the key is the parent of the value. See
<code>RelationalTagConnection._TAG_TAG_TYPES</code> for possible values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, tags:Union[List[Union[str,&#39;RelationalTag&#39;]],Dict[str,Union[str,List[str]]]], tag_tag_type:int=&#39;RelationalTagConnection.TO_TAG_CHILD&#39;) -&gt; List[&#39;RelationalTag&#39;]:
    &#34;&#34;&#34;Load a set of tags, including optional connection info for each.
    
    There are multiple ways to define a relational tags system:
    
    ## From Save
    
    Pass a list of `RelationalTag` instances as the `tags` arg.
    
    ## Flat
    
    Pass a list of tag name strings. Tags will not have any relationships with each other.
    Repeated tag names are allowed.
    
    Example:
    
    ```
    [&#39;apple&#39;,&#39;banana&#39;,&#39;cinnamon&#39;,&#39;donut&#39;]
    ```
    
    ## Hierarchy
    
    Pass a dict, where each key is a tag name string, and each value is either a single
    tag name, or a list of tag names. Repeated tag names are allowed in both keys and values.
    
    Example:
    
    ```
    {
        &#39;fruit&#39;: [&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;],
        &#39;food&#39;: [&#39;fruit&#39;,&#39;vegetable&#39;],
        &#39;color&#39;: [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;orange&#39;],
        &#39;sport&#39;: &#39;football&#39;
    }
    ```
    
    ## Args
    
    **tags** Relational tags, either as a list or dict. Entities not supported.
    
    **tag_tag_type** Specify what a key-value relationship in a dictionary means. Default
    of `RelationalTagConnection.TO_TAG_CHILD` means the key is the parent of the value. See 
    `RelationalTagConnection._TAG_TAG_TYPES` for possible values.
    &#34;&#34;&#34;
    
    if isinstance(tags, List):
        for tag in tags:
            if isinstance(tag,RelationalTag):
                if tag in all_tags:
                    log.warning(&#39;duplicate tag {} on load&#39;.format(tag))
                
                all_tags[tag.name] = tag
            
            elif isinstance(tag,str):
                cls.new(tag, get_if_exists=True)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported tag type {}&#39;.format(type(tag)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag in tags
        
    elif isinstance(tags, Dict):
        for tag, value in tags.items():
            # create new parent tag
            rtag = cls.new(tag, get_if_exists=True)
            
            if isinstance(value,List):
                # tag to many
                for val in value:
                    ttag = cls.get(val, new_if_missing=True)
                    cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
            
            elif isinstance(value,str):
                # tag to one
                ttag = cls.get(value, new_if_missing=True)
                cls.connect(tag_or_connection=rtag, target=ttag, connection_type=tag_tag_type)
            
            else:
                raise RelationalTagError(
                    &#39;unsupported target type {}&#39;.format(type(value)),
                    type=RelationalTagError.TYPE_WRONG_TYPE
                )
        # end for tag,value in tags
        
    else:
        raise RelationalTagError(
            &#39;unsupported tags type {}&#39;.format(type(tags)),
            type=RelationalTagError.TYPE_WRONG_TYPE
        )
    
    return list(cls.all_tags.values())</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.load_json"><code class="name flex">
<span>def <span class="ident">load_json</span></span>(<span>json_in: str) ‑> List[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load all tags and connections from a json string created by <code><a title="relational_tags.RelationalTag.save_json" href="#relational_tags.RelationalTag.save_json">RelationalTag.save_json()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_json(cls, json_in:str) -&gt; List[&#39;RelationalTag&#39;]:
    &#34;&#34;&#34;Load all tags and connections from a json string created by `RelationalTag.save_json`.
    &#34;&#34;&#34;
    
    tag_dicts:List[Dict] = json.loads(json_in)
    
    cls.load(tags=[
        cls.load_tag(tag_dict)
        for tag_dict in tag_dicts
    ])
    
    return list(cls.all_tags.values())</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.load_tag"><code class="name flex">
<span>def <span class="ident">load_tag</span></span>(<span>tag_str: Union[str, Dict], get_if_exists: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a tag from its json string representation, or equivalent dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_tag(cls, tag_str:Union[str,Dict], get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
    &#34;&#34;&#34;Load a tag from its json string representation, or equivalent dict.
    &#34;&#34;&#34;
    
    # { name: [ [src,type,target] ... ] }
    if isinstance(tag_str,Dict):
        tag_json = tag_str
    else:
        tag_json:Dict[str,List[List[str]]] = json.loads(tag_str)
    
    tag = cls.new(list(tag_json.keys())[0], get_if_exists)
    
    conn_arrs = tag_json[tag.name]
    for conn_arr in conn_arrs:
        connection_type = RelationalTagConnection.str_to_type(conn_arr[1])
        if connection_type in RelationalTagConnection._TAG_TAG_TYPES:
            target_tag = cls.get(conn_arr[2])
            
            cls.connect(
                tag_or_connection=tag, 
                connection_type=connection_type,
                target=target_tag
            )
        
        else:
            try:
                target_entity_json:Dict = conn_arr[2]
                target_entity_cls:Type = RelationalEntity.classes[
                    target_entity_json[RelationalEntity._ATTR_CLASS]
                ]
                
                target_entity:RelationalEntity = target_entity_cls.load_entity(
                    entity_json=target_entity_json
                )
                
                cls.connect(
                    tag_or_connection=tag,
                    connection_type=connection_type,
                    target=target_entity
                )
                
            except (KeyError, json.decoder.JSONDecodeError) as e:
                cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}-{}&#39;.format(
                    conn_arr[2],
                    conn_arr[0], 
                    connection_type,
                    conn_arr[2]
                ))
    # end for conn_str in conns
    
    return tag</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>name: str, get_if_exists: bool = True) ‑> <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new(cls, name:str, get_if_exists:bool=True) -&gt; &#39;RelationalTag&#39;:
    if not cls._is_case_sensitive:
        name = name.lower()
    
    try:
        rtag = RelationalTag(name=name)
        return rtag
    
    except RelationalTagError as e:
        cls.log.warning(str(e))
        
        if e.type == RelationalTagError.TYPE_COLLISION and get_if_exists:
            return cls.all_tags[name]
        else:
            raise e
    # end except</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.save_json"><code class="name flex">
<span>def <span class="ident">save_json</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Save all tags and connections as a json string.</p>
<p>Entities not included.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_json(cls) -&gt; str:
    &#34;&#34;&#34;Save all tags and connections as a json string.
    
    Entities not included.
    &#34;&#34;&#34;
    
    return &#39;[{}]&#39;.format(
        &#39;,&#39;.join([
            str(tag) for tag in cls.all_tags.values()
        ])
    )</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.save_tag"><code class="name flex">
<span>def <span class="ident">save_tag</span></span>(<span>tag: Union[str, ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>')]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Export the given tag or tag of given name as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_tag(cls, tag:Union[str,&#39;RelationalTag&#39;]) -&gt; str:
    &#34;&#34;&#34;Export the given tag or tag of given name as a string.&#34;&#34;&#34;
    
    # convert to RelationalTag
    if isinstance(tag,str):
        tag = cls.get(name=tag, new_if_missing=False)
    
    # export
    return str(tag)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="relational_tags.RelationalTag.connect_to"><code class="name flex">
<span>def <span class="ident">connect_to</span></span>(<span>self, other: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any], connection_type: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect tag to another tag or entity.</p>
<p>Calls the class method <code><a title="relational_tags.RelationalTag.connect" href="#relational_tags.RelationalTag.connect">RelationalTag.connect()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_to(self, other:Union[&#39;RelationalTag&#39;,Any], connection_type:int=None):
    &#34;&#34;&#34;Connect tag to another tag or entity.
    
    Calls the class method `RelationalTag.connect`.
    &#34;&#34;&#34;
    
    type(self).connect(
        tag_or_connection=self,
        target=other,
        connection_type=connection_type
    )</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.delete_self"><code class="name flex">
<span>def <span class="ident">delete_self</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_self(self):
    type(self).delete(self)</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTag.disconnect_to"><code class="name flex">
<span>def <span class="ident">disconnect_to</span></span>(<span>self, other: Union[ForwardRef('<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect tag from another tag or entity.</p>
<p>Calls the class method <code><a title="relational_tags.RelationalTag.disconnect" href="#relational_tags.RelationalTag.disconnect">RelationalTag.disconnect()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_to(self, other:Union[&#39;RelationalTag&#39;,Any]):
    &#34;&#34;&#34;Disconnect tag from another tag or entity.
    
    Calls the class method `RelationalTag.disconnect`.
    &#34;&#34;&#34;
    
    type(self).disconnect(tag=self,target=other)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="relational_tags.RelationalTagConnection"><code class="flex name class">
<span>class <span class="ident">RelationalTagConnection</span></span>
<span>(</span><span>source: <a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, target: Union[<a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a>, Any], connection_type=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Relational tag connection.</p>
<p>RelationalTagConnection constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalTagConnection:
    &#34;&#34;&#34;Relational tag connection.
    &#34;&#34;&#34;
    
    log:logging.Logger = logging.getLogger(&#39;{}.RelationalTagConnection&#39;.format(__name__))
    
    TO_TAG_UNDIRECTED:int = 1
    &#34;&#34;&#34;Undirected tag-tag connection.&#34;&#34;&#34;
    TO_TAG_PARENT:int = 2
    &#34;&#34;&#34;Child-parent tag-tag connection.&#34;&#34;&#34;
    TO_TAG_CHILD:int = 3
    &#34;&#34;&#34;Parent-child tag-tag connection.&#34;&#34;&#34;
    TO_ENT:int = 4
    &#34;&#34;&#34;Tag-entity connection.&#34;&#34;&#34;
    ENT_TO_TAG:int = 5
    &#34;&#34;&#34;Entity-tag connection.&#34;&#34;&#34;
    
    _TAG_TAG_TYPES:List[int] = [TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD]
    &#34;&#34;&#34;All tag-tag connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    &#34;&#34;&#34;
    
    _TAG_ENT_TYPES:List[int] = [TO_ENT,ENT_TO_TAG]
    &#34;&#34;&#34;All tag-entity connection types.
    
    ## Items
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    _TYPES:List[int] = [
        TO_TAG_UNDIRECTED,TO_TAG_PARENT,TO_TAG_CHILD,TO_ENT,ENT_TO_TAG
    ]
    &#34;&#34;&#34;All connection types.
    
    ## Items
    
    `TO_TAG_UNDIRECTED`
    
    `TO_TAG_PARENT`
    
    `TO_TAG_CHILD`
    
    `TO_ENT`
    
    `ENT_TO_TAG`
    &#34;&#34;&#34;
    
    @classmethod
    def type_to_str(cls,type:int) -&gt; str:
        &#34;&#34;&#34;Convert connection type code to string.
        &#34;&#34;&#34;
        
        if type == cls.TO_TAG_UNDIRECTED:
            return &#39;to-tag-undirected&#39;
        
        elif type == cls.TO_TAG_PARENT:
            return &#39;to-tag-parent&#39;
        
        elif type == cls.TO_TAG_CHILD:
            return &#39;to-tag-child&#39;
            
        elif type == cls.TO_ENT:
            return &#39;to-entity&#39;
            
        elif type == cls.ENT_TO_TAG:
            return &#39;entity-to-tag&#39;
    # end type_to_str
    
    @classmethod
    def str_to_type(cls,string:str) -&gt; int:
        &#34;&#34;&#34;Convert connection type string to code.
        &#34;&#34;&#34;
        
        if string == &#39;to-tag-undirected&#39;:
            return cls.TO_TAG_UNDIRECTED
        
        elif string == &#39;to-tag-parent&#39;:
            return cls.TO_TAG_PARENT
        
        elif string == &#39;to-tag-child&#39;:
            return cls.TO_TAG_CHILD
            
        elif string == &#39;to-entity&#39;:
            return cls.TO_ENT
            
        elif string == &#39;entity-to-tag&#39;:
            return cls.ENT_TO_TAG
    # end str_to_type
    
    @classmethod
    def inverse_type(cls,type:int) -&gt; int:
        if type == cls.TO_TAG_PARENT:
            return cls.TO_TAG_CHILD
        
        elif type == cls.TO_TAG_CHILD:
            return cls.TO_TAG_PARENT
        
        elif type == cls.TO_ENT:
            return cls.ENT_TO_TAG
            
        elif type == cls.ENT_TO_TAG:
            return cls.TO_ENT
            
        else:
            return type
    # end reverse_type
    
    @classmethod
    def load_connection(cls, connection_str:str) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Load connection from string representation.
        &#34;&#34;&#34;
        
        connection_arr:List[str] = json.loads(connection_str)
        
        if len(connection_arr) == 3:
            source_str = connection_arr[0]
            connection_type = cls.str_to_type(connection_arr[1])
            target_str = connection_arr[2]
            invert:bool = False
            
            # load source
            if isinstance(source_str,str):
                source:RelationalTag = RelationalTag.get(source_str)
                invert = False
                
            else:
                invert = True
                
                try:
                    source_json:Dict = source_str
                    source_cls:Type = RelationalEntity.classes[
                        source_json[RelationalEntity._ATTR_CLASS]
                    ]
                    source:RelationalEntity = source_cls(source_json)
                
                except:
                    cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}&#39;.format(
                        source_str,
                        source_str, 
                        target_str
                    ))
                    return None
            # end else not str
            
            # load target
            if isinstance(target_str,str):
                target:RelationalTag = RelationalTag.get(target_str)
                
            else:
                try:
                    target_json:Dict = source_str
                    target_cls:Type = RelationalEntity.classes[
                        target_json[RelationalEntity._ATTR_CLASS]
                    ]
                    target:RelationalEntity = target_cls(target_json)
                
                except:
                    cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}&#39;.format(
                        target_str,
                        source_str, 
                        target_str
                    ))
                    return None
            # end else not str
            
            if invert:
                temp = source
                source = target
                target = temp
                del temp
            
            # load connection
            RelationalTag.connect(
                tag_or_connection=source,
                target=target,
                connection_type=connection_type
            )
            
        else:
            raise RelationalTagError(
                &#39;invalid connection string {}&#39;.format(connection_str),
                RelationalTagError.TYPE_FORMAT
            )
    # end load_connection
    
    def __init__(self, source:RelationalTag, target:Union[RelationalTag,Any], connection_type=TO_ENT):
        &#34;&#34;&#34;RelationalTagConnection constructor.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        self.source:RelationalTag = source
        &#34;&#34;&#34;Connection source; must be a `RelationalTag`.
        &#34;&#34;&#34;
        
        self.target:Union[RelationalTag,Any] = target
        &#34;&#34;&#34;Connection target; either a `RelationalTag`, or an entity.
        &#34;&#34;&#34;
        
        self.type = connection_type
        &#34;&#34;&#34;Connection type. See `_TYPES` for possible values.
        &#34;&#34;&#34;
        
        if self.type in cls._TAG_TAG_TYPES and not isinstance(target,RelationalTag):
            raise RelationalTagError(
                &#39;cannot create {} connection with non-tag {}&#39;.format(
                    cls.type_to_str(self.type),
                    target
                ),
                RelationalTagError.TYPE_WRONG_TYPE
            )
    # end __init__
    
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;RelationalTagConnection string representation.
        &#34;&#34;&#34;
        
        cls = type(self)
        
        if isinstance(self.source,RelationalTag):
            # don&#39;t use __str__, as it would case recursion
            source_str = &#39;&#34;{}&#34;&#39;.format(self.source.name)
        else:
            source_str = str(self.source)
        
        if isinstance(self.target,RelationalTag):
            # don&#39;t use __str__, as it would case recursion
            target_str = &#39;&#34;{}&#34;&#39;.format(self.target.name)
        else:
            target_str = str(self.target)
        
        return &#39;[{},&#34;{}&#34;,{}]&#39;.format(source_str,cls.type_to_str(self.type),target_str)
    # end __str__
    
    def __eq__(self, other) -&gt; bool:
        return isinstance(other,RelationalTagConnection) and hash(self) == hash(other)
    # end __eq__
    
    def __hash__(self):
        return hash((self.source, self.target, self.type))
    # end __hash__
    
    def inverse(self) -&gt; &#39;RelationalTagConnection&#39;:
        &#34;&#34;&#34;Return inverse connection.
        &#34;&#34;&#34;
        
        return RelationalTagConnection(
            source=self.target,
            target=self.source,
            connection_type=type(self).inverse_type(self.type)
        )
    # end inverse
    
    def disconnect(self):
        &#34;&#34;&#34;Disconnect source and target.
        
        Convenience method for `RelationalTag.disconnect`.
        &#34;&#34;&#34;
        
        RelationalTag.disconnect(tag_or_connection=self)
    # end disconnect</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.ENT_TO_TAG"><code class="name">var <span class="ident">ENT_TO_TAG</span> : int</code></dt>
<dd>
<div class="desc"><p>Entity-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_ENT"><code class="name">var <span class="ident">TO_ENT</span> : int</code></dt>
<dd>
<div class="desc"><p>Tag-entity connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_TAG_CHILD"><code class="name">var <span class="ident">TO_TAG_CHILD</span> : int</code></dt>
<dd>
<div class="desc"><p>Parent-child tag-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_TAG_PARENT"><code class="name">var <span class="ident">TO_TAG_PARENT</span> : int</code></dt>
<dd>
<div class="desc"><p>Child-parent tag-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.TO_TAG_UNDIRECTED"><code class="name">var <span class="ident">TO_TAG_UNDIRECTED</span> : int</code></dt>
<dd>
<div class="desc"><p>Undirected tag-tag connection.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.log"><code class="name">var <span class="ident">log</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.inverse_type"><code class="name flex">
<span>def <span class="ident">inverse_type</span></span>(<span>type: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def inverse_type(cls,type:int) -&gt; int:
    if type == cls.TO_TAG_PARENT:
        return cls.TO_TAG_CHILD
    
    elif type == cls.TO_TAG_CHILD:
        return cls.TO_TAG_PARENT
    
    elif type == cls.TO_ENT:
        return cls.ENT_TO_TAG
        
    elif type == cls.ENT_TO_TAG:
        return cls.TO_ENT
        
    else:
        return type</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTagConnection.load_connection"><code class="name flex">
<span>def <span class="ident">load_connection</span></span>(<span>connection_str: str) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load connection from string representation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_connection(cls, connection_str:str) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Load connection from string representation.
    &#34;&#34;&#34;
    
    connection_arr:List[str] = json.loads(connection_str)
    
    if len(connection_arr) == 3:
        source_str = connection_arr[0]
        connection_type = cls.str_to_type(connection_arr[1])
        target_str = connection_arr[2]
        invert:bool = False
        
        # load source
        if isinstance(source_str,str):
            source:RelationalTag = RelationalTag.get(source_str)
            invert = False
            
        else:
            invert = True
            
            try:
                source_json:Dict = source_str
                source_cls:Type = RelationalEntity.classes[
                    source_json[RelationalEntity._ATTR_CLASS]
                ]
                source:RelationalEntity = source_cls(source_json)
            
            except:
                cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}&#39;.format(
                    source_str,
                    source_str, 
                    target_str
                ))
                return None
        # end else not str
        
        # load target
        if isinstance(target_str,str):
            target:RelationalTag = RelationalTag.get(target_str)
            
        else:
            try:
                target_json:Dict = source_str
                target_cls:Type = RelationalEntity.classes[
                    target_json[RelationalEntity._ATTR_CLASS]
                ]
                target:RelationalEntity = target_cls(target_json)
            
            except:
                cls.log.warning(&#39;loading of a tag-entity connection for {} is not supported: {}-{}&#39;.format(
                    target_str,
                    source_str, 
                    target_str
                ))
                return None
        # end else not str
        
        if invert:
            temp = source
            source = target
            target = temp
            del temp
        
        # load connection
        RelationalTag.connect(
            tag_or_connection=source,
            target=target,
            connection_type=connection_type
        )
        
    else:
        raise RelationalTagError(
            &#39;invalid connection string {}&#39;.format(connection_str),
            RelationalTagError.TYPE_FORMAT
        )</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTagConnection.str_to_type"><code class="name flex">
<span>def <span class="ident">str_to_type</span></span>(<span>string: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Convert connection type string to code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def str_to_type(cls,string:str) -&gt; int:
    &#34;&#34;&#34;Convert connection type string to code.
    &#34;&#34;&#34;
    
    if string == &#39;to-tag-undirected&#39;:
        return cls.TO_TAG_UNDIRECTED
    
    elif string == &#39;to-tag-parent&#39;:
        return cls.TO_TAG_PARENT
    
    elif string == &#39;to-tag-child&#39;:
        return cls.TO_TAG_CHILD
        
    elif string == &#39;to-entity&#39;:
        return cls.TO_ENT
        
    elif string == &#39;entity-to-tag&#39;:
        return cls.ENT_TO_TAG</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTagConnection.type_to_str"><code class="name flex">
<span>def <span class="ident">type_to_str</span></span>(<span>type: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert connection type code to string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def type_to_str(cls,type:int) -&gt; str:
    &#34;&#34;&#34;Convert connection type code to string.
    &#34;&#34;&#34;
    
    if type == cls.TO_TAG_UNDIRECTED:
        return &#39;to-tag-undirected&#39;
    
    elif type == cls.TO_TAG_PARENT:
        return &#39;to-tag-parent&#39;
    
    elif type == cls.TO_TAG_CHILD:
        return &#39;to-tag-child&#39;
        
    elif type == cls.TO_ENT:
        return &#39;to-entity&#39;
        
    elif type == cls.ENT_TO_TAG:
        return &#39;entity-to-tag&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.source"><code class="name">var <span class="ident">source</span></code></dt>
<dd>
<div class="desc"><p>Connection source; must be a <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code>.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.target"><code class="name">var <span class="ident">target</span></code></dt>
<dd>
<div class="desc"><p>Connection target; either a <code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code>, or an entity.</p></div>
</dd>
<dt id="relational_tags.RelationalTagConnection.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Connection type. See <code>_TYPES</code> for possible values.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="relational_tags.RelationalTagConnection.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect source and target.</p>
<p>Convenience method for <code><a title="relational_tags.RelationalTag.disconnect" href="#relational_tags.RelationalTag.disconnect">RelationalTag.disconnect()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect source and target.
    
    Convenience method for `RelationalTag.disconnect`.
    &#34;&#34;&#34;
    
    RelationalTag.disconnect(tag_or_connection=self)</code></pre>
</details>
</dd>
<dt id="relational_tags.RelationalTagConnection.inverse"><code class="name flex">
<span>def <span class="ident">inverse</span></span>(<span>self) ‑> <a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return inverse connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse(self) -&gt; &#39;RelationalTagConnection&#39;:
    &#34;&#34;&#34;Return inverse connection.
    &#34;&#34;&#34;
    
    return RelationalTagConnection(
        source=self.target,
        target=self.source,
        connection_type=type(self).inverse_type(self.type)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="relational_tags.RelationalTagError"><code class="flex name class">
<span>class <span class="ident">RelationalTagError</span></span>
<span>(</span><span>message, type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Relational tag error.</p>
<p>RelationalTagError constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationalTagError(Exception):
    &#34;&#34;&#34;Relational tag error.
    &#34;&#34;&#34;
    
    TYPE_COLLISION = 1
    TYPE_MISSING = 2
    TYPE_WRONG_TYPE = 3
    TYPE_HASH_FAIL = 4
    TYPE_FORMAT = 5
    
    def __init__(self, message, type=TYPE_COLLISION):
        &#34;&#34;&#34;RelationalTagError constructor.
        &#34;&#34;&#34;
        
        super().__init__(message)
        
        self.type = type
    # end __init__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="relational_tags.RelationalTagError.TYPE_COLLISION"><code class="name">var <span class="ident">TYPE_COLLISION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_FORMAT"><code class="name">var <span class="ident">TYPE_FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_HASH_FAIL"><code class="name">var <span class="ident">TYPE_HASH_FAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_MISSING"><code class="name">var <span class="ident">TYPE_MISSING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="relational_tags.RelationalTagError.TYPE_WRONG_TYPE"><code class="name">var <span class="ident">TYPE_WRONG_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="relational_tags.VERSION" href="#relational_tags.VERSION">VERSION</a></code></li>
<li><code><a title="relational_tags.all_tags" href="#relational_tags.all_tags">all_tags</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="relational_tags.clear" href="#relational_tags.clear">clear</a></code></li>
<li><code><a title="relational_tags.config" href="#relational_tags.config">config</a></code></li>
<li><code><a title="relational_tags.connect" href="#relational_tags.connect">connect</a></code></li>
<li><code><a title="relational_tags.delete" href="#relational_tags.delete">delete</a></code></li>
<li><code><a title="relational_tags.disconnect" href="#relational_tags.disconnect">disconnect</a></code></li>
<li><code><a title="relational_tags.get" href="#relational_tags.get">get</a></code></li>
<li><code><a title="relational_tags.get_tagged_entities" href="#relational_tags.get_tagged_entities">get_tagged_entities</a></code></li>
<li><code><a title="relational_tags.load" href="#relational_tags.load">load</a></code></li>
<li><code><a title="relational_tags.load_json" href="#relational_tags.load_json">load_json</a></code></li>
<li><code><a title="relational_tags.load_tag" href="#relational_tags.load_tag">load_tag</a></code></li>
<li><code><a title="relational_tags.new" href="#relational_tags.new">new</a></code></li>
<li><code><a title="relational_tags.save_json" href="#relational_tags.save_json">save_json</a></code></li>
<li><code><a title="relational_tags.save_tag" href="#relational_tags.save_tag">save_tag</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="relational_tags.RelationalEntity" href="#relational_tags.RelationalEntity">RelationalEntity</a></code></h4>
<ul class="">
<li><code><a title="relational_tags.RelationalEntity.classes" href="#relational_tags.RelationalEntity.classes">classes</a></code></li>
<li><code><a title="relational_tags.RelationalEntity.load_entity" href="#relational_tags.RelationalEntity.load_entity">load_entity</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="relational_tags.RelationalTag" href="#relational_tags.RelationalTag">RelationalTag</a></code></h4>
<ul class="two-column">
<li><code><a title="relational_tags.RelationalTag.all_tags" href="#relational_tags.RelationalTag.all_tags">all_tags</a></code></li>
<li><code><a title="relational_tags.RelationalTag.clear" href="#relational_tags.RelationalTag.clear">clear</a></code></li>
<li><code><a title="relational_tags.RelationalTag.config" href="#relational_tags.RelationalTag.config">config</a></code></li>
<li><code><a title="relational_tags.RelationalTag.connect" href="#relational_tags.RelationalTag.connect">connect</a></code></li>
<li><code><a title="relational_tags.RelationalTag.connect_to" href="#relational_tags.RelationalTag.connect_to">connect_to</a></code></li>
<li><code><a title="relational_tags.RelationalTag.delete" href="#relational_tags.RelationalTag.delete">delete</a></code></li>
<li><code><a title="relational_tags.RelationalTag.delete_self" href="#relational_tags.RelationalTag.delete_self">delete_self</a></code></li>
<li><code><a title="relational_tags.RelationalTag.disconnect" href="#relational_tags.RelationalTag.disconnect">disconnect</a></code></li>
<li><code><a title="relational_tags.RelationalTag.disconnect_to" href="#relational_tags.RelationalTag.disconnect_to">disconnect_to</a></code></li>
<li><code><a title="relational_tags.RelationalTag.get" href="#relational_tags.RelationalTag.get">get</a></code></li>
<li><code><a title="relational_tags.RelationalTag.get_tagged_entities" href="#relational_tags.RelationalTag.get_tagged_entities">get_tagged_entities</a></code></li>
<li><code><a title="relational_tags.RelationalTag.load" href="#relational_tags.RelationalTag.load">load</a></code></li>
<li><code><a title="relational_tags.RelationalTag.load_json" href="#relational_tags.RelationalTag.load_json">load_json</a></code></li>
<li><code><a title="relational_tags.RelationalTag.load_tag" href="#relational_tags.RelationalTag.load_tag">load_tag</a></code></li>
<li><code><a title="relational_tags.RelationalTag.log" href="#relational_tags.RelationalTag.log">log</a></code></li>
<li><code><a title="relational_tags.RelationalTag.new" href="#relational_tags.RelationalTag.new">new</a></code></li>
<li><code><a title="relational_tags.RelationalTag.save_json" href="#relational_tags.RelationalTag.save_json">save_json</a></code></li>
<li><code><a title="relational_tags.RelationalTag.save_tag" href="#relational_tags.RelationalTag.save_tag">save_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="relational_tags.RelationalTagConnection" href="#relational_tags.RelationalTagConnection">RelationalTagConnection</a></code></h4>
<ul class="two-column">
<li><code><a title="relational_tags.RelationalTagConnection.ENT_TO_TAG" href="#relational_tags.RelationalTagConnection.ENT_TO_TAG">ENT_TO_TAG</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_ENT" href="#relational_tags.RelationalTagConnection.TO_ENT">TO_ENT</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_TAG_CHILD" href="#relational_tags.RelationalTagConnection.TO_TAG_CHILD">TO_TAG_CHILD</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_TAG_PARENT" href="#relational_tags.RelationalTagConnection.TO_TAG_PARENT">TO_TAG_PARENT</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.TO_TAG_UNDIRECTED" href="#relational_tags.RelationalTagConnection.TO_TAG_UNDIRECTED">TO_TAG_UNDIRECTED</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.disconnect" href="#relational_tags.RelationalTagConnection.disconnect">disconnect</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.inverse" href="#relational_tags.RelationalTagConnection.inverse">inverse</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.inverse_type" href="#relational_tags.RelationalTagConnection.inverse_type">inverse_type</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.load_connection" href="#relational_tags.RelationalTagConnection.load_connection">load_connection</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.log" href="#relational_tags.RelationalTagConnection.log">log</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.source" href="#relational_tags.RelationalTagConnection.source">source</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.str_to_type" href="#relational_tags.RelationalTagConnection.str_to_type">str_to_type</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.target" href="#relational_tags.RelationalTagConnection.target">target</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.type" href="#relational_tags.RelationalTagConnection.type">type</a></code></li>
<li><code><a title="relational_tags.RelationalTagConnection.type_to_str" href="#relational_tags.RelationalTagConnection.type_to_str">type_to_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="relational_tags.RelationalTagError" href="#relational_tags.RelationalTagError">RelationalTagError</a></code></h4>
<ul class="">
<li><code><a title="relational_tags.RelationalTagError.TYPE_COLLISION" href="#relational_tags.RelationalTagError.TYPE_COLLISION">TYPE_COLLISION</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_FORMAT" href="#relational_tags.RelationalTagError.TYPE_FORMAT">TYPE_FORMAT</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_HASH_FAIL" href="#relational_tags.RelationalTagError.TYPE_HASH_FAIL">TYPE_HASH_FAIL</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_MISSING" href="#relational_tags.RelationalTagError.TYPE_MISSING">TYPE_MISSING</a></code></li>
<li><code><a title="relational_tags.RelationalTagError.TYPE_WRONG_TYPE" href="#relational_tags.RelationalTagError.TYPE_WRONG_TYPE">TYPE_WRONG_TYPE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>